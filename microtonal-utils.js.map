{
  "version": 3,
  "sources": [
    "../../.nvm/versions/node/v14.5.0/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "lib/approx.js",
    "lib/edo.js",
    "lib/english.js",
    "lib/fjs.js",
    "lib/index.js",
    "lib/interval.js",
    "lib/parser.js",
    "lib/parser/eval.js",
    "lib/parser/grammar-helpers.js",
    "lib/parser/grammar.js",
    "lib/pythagorean.js",
    "node_modules/fraction.js/fraction.js",
    "node_modules/mathutils/index.js",
    "node_modules/nearley/lib/nearley.js",
    "node_modules/number-to-words/numberToWords.min.js",
    "node_modules/primes-and-factors/build/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACl0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "/**\n * Best rational and EDO approximations of intervals\n * @copyright 2021 Matthew Yacavone (matthew [at] yacavone [dot] net)\n * @module approx\n **/\n\nconst pf = require('primes-and-factors');\nconst Fraction = require('fraction.js');\nconst Interval = require('./interval.js');\nconst {edoApprox} = require('./edo.js');\n\nfunction signPerms(intv) {\n  const keys = Object.keys(intv);\n  let ret = [];\n  for (let bits = 0; bits < (1 << keys.length); bits++) {\n    ret.push(keys.map((_,i) => (bits & (1 << i)) == 0 ? 1 : -1));\n  }\n  return ret;\n}\n\nfunction applySignPerm(sp, intv) {\n  let [i, ret] = [0, {}];\n  for (const [p,e] of Object.entries(intv)) {\n    ret[p] = e.mul(sp[i]);\n    i++;\n  }\n  return Interval(ret);\n}\n\n/**\n  * Finds best rational approximations of the given interval, sorted by Tenney\n  * harmonic distance. Returns a pair whose first element is true iff no better\n  * approximaions can be found - i.e. if either an exact approximation is found\n  * or there are no more intervals in the given odd-limit to check.\n  *\n  * @param {Interval} i\n  * @param {Object} [opts]\n  * @param {integer} [opts.cutoff] defaults to 50 cents\n  * @param {integer} [opts.primeLimit]\n  * @param {integer} [opts.oddLimit]\n  * @param {integer} [opts.startIteration] defaults to 0\n  * @param {integer} [opts.numIterations] defaults to 1\n  * @param {boolean} [opts.useExactDiffs] defaults to false, controls the type\n  *                                       of each 'diff' property\n  * @returns {Pair.<boolean, Array.<{ratio: Fraction, diff: (number|Interval)}>>}\n  */\nfunction bestRationalApproxs(a,b, opts) {\n  // if only two arguments are given, the second one may be `opts`!\n  if (!opts) {\n    if (typeof b == 'object' && b != null) {\n      opts = b;\n      b = undefined;\n    } else {\n      opts = {};\n    }\n  }\n  const intv = Interval(a,b);\n  console.time(\"rationalApprox\");\n  let {cutoff, primeLimit, oddLimit, startIteration, numIterations, useExactDiffs} = opts;\n  let [hitOddLimitMax, foundExact] = [false, false];\n\n  // some heuristics for the iteration size, i.e. the number of odd numbers\n  // to check in a given iteration\n  let iterationSize = 100;\n  if (primeLimit) {\n    // for large prime limits, this iteration size is approximately half the\n    // prime limit itself, but for small prime limits (roughly less than 47)\n    // this is larger, to account for the fact that valid intervals are sparser\n    iterationSize = Math.ceil(2000/primeLimit + (primeLimit+1)/2);\n    // a prime limit of 2 means we also have an odd limit of 1!\n    if (primeLimit <= 2) { oddLimit = 1; }\n  }\n\n  // the size of the largest odd number which would generate a valid interval\n  // in our odd limit\n  const oddLimit_max = oddLimit * Math.abs(oddLimit-2);\n  if (oddLimit) {\n    iterationSize = Math.min(iterationSize, Math.ceil((oddLimit_max+1)/2));\n  }\n\n  if (cutoff == undefined) { cutoff = Interval(2).pow(1,12).sqrt(); }\n  if (primeLimit == undefined && oddLimit) { primeLimit = oddLimit; }\n  if (startIteration == undefined) { startIteration = 0; }\n  if (numIterations == undefined) { numIterations = 1; }\n  let n_max = (startIteration + numIterations) * iterationSize;\n\n  // if our n_max is greater than the largest odd number which would generate a\n  // valid interval in our odd limit, we don't have to check any more than that!\n  if (oddLimit && n_max >= (oddLimit_max+1)/2) {\n    n_max = (oddLimit_max+1)/2;\n    hitOddLimitMax = true;\n  }\n\n  const intv_red = intv.red();\n  const vs = intv.div(intv_red);\n  let [last_diff, ret] = [Interval(2), []];\n  // this loop iterates through all odd numbers `2*n + 1` for `n` in the range\n  // `[startIteration * iterationSize + 1, numIterations * iterationSize)`\n  for (let n = startIteration * iterationSize; !foundExact && n < n_max; n++) {\n    const i = Interval(2*n + 1);\n    if (primeLimit && Object.keys(i).some(p => p > primeLimit)) {\n      continue;\n    }\n    // For a given odd `i` with factorization `p1^e1 ... pm^em` (where `pk` is\n    // prime and `ek > 0` for all `k`), `i_perms` is the array of all intervals\n    // with factorizations `p1^(+/- e1) ... pm^(+/- em)`. For example, if\n    // `i = 45` then `i = 3^2 * 5^1` and\n    // `i_perms = [ 3^2 * 5^1, 3^(-2) * 5^1, 3^2 * 5^(-1), 3^(-2) * 5(-1) ]`.\n    const i_perms = signPerms(i).map(sp => applySignPerm(sp, i));\n    // For each of these factorizations, we then add in the power of 2 which\n    // gets it closest to `intv`, then package the result up with its difference\n    // to `intv`. We do the former by finding the balanced octave-reduced\n    // difference to `intv` then adding this difference back to `intv`; the\n    // result will always be our original factorization times the power of 2\n    // which minimizes its difference to `intv`\n    const to_check = i_perms.map(function (j) {\n                       const diff = j.div(intv).reb();\n                       return [intv.mul(diff), diff];\n                     }).sort((a,b) => a[1].compare(b[1]));\n    for (const [j, diff] of to_check) {\n      const ratio = j.toFrac();\n      if (oddLimit && (   (ratio.n % 2 != 0 && ratio.n > oddLimit)\n                       || (ratio.d % 2 != 0 && ratio.d > oddLimit))) {\n        continue;\n      }\n      const abs_diff = diff.compare(1) < 0 ? diff.recip() : diff;\n      if (abs_diff.compare(cutoff) < 0 && abs_diff.compare(last_diff) <= 0) {\n        ret.push({ ratio: ratio, diff: useExactDiffs ? diff : diff.toCents() });\n        last_diff = abs_diff;\n        if (last_diff.equals(1)) { foundExact = true };\n      }\n    }\n  }\n  console.timeEnd(\"rationalApprox\");\n  if (hitOddLimitMax || foundExact) { console.log(\"rationalApprox: exhausted\") }\n  return [hitOddLimitMax || foundExact, ret];\n}\n\n/**\n  * Finds best EDO step approximations of the given interval, sorted by EDO\n  * size.\n  *\n  * @param {Interval} i\n  * @param {Object} [opts]\n  * @param {integer} [opts.cutoff] defaults to 50 cents\n  * @param {integer} [opts.startEDO] defaults to 5\n  * @param {integer} [opts.endEDO] defaults to 60\n  * @param {boolean} [opts.useExactDiffs] defaults to false, controls the type\n  *                                       of each 'diff' property\n  * @returns {Array.<{steps: Array, diff: (number|Interval)}>}\n  */\nfunction bestEDOApproxsByEDO(a,b, opts) {\n  // if only two arguments are given, the second one may be `opts`!\n  if (!opts) {\n    if (typeof b == 'object' && b != null) {\n      opts = b;\n      b = undefined;\n    } else {\n      opts = {};\n    }\n  }\n  const intv = Interval(a,b);\n  if (opts == undefined) { opts = {}; }\n  let {cutoff, startEDO, endEDO, useExactDiffs} = opts;\n  if (cutoff == undefined) { cutoff = Interval(2).pow(1,12).sqrt(); }\n  if (startEDO == undefined) { startEDO = 5; }\n  if (endEDO == undefined) { endEDO = 60; }\n\n  let foundExact = false;\n  let [last_diff, ret] = [Interval(2), []];\n  for (let edo = startEDO; !foundExact && edo <= endEDO; edo++) {\n    const steps = edoApprox(edo, intv);\n    const diff = intv.div(Interval(2).pow(steps,edo));\n    const abs_diff = diff.compare(1) < 0 ? diff.recip() : diff;\n    if (abs_diff.compare(cutoff) < 0 && abs_diff.compare(last_diff) <= 0) {\n      if (abs_diff.compare(last_diff) == 0) {\n        ret[ret.length - 1].steps.push([steps, edo]);\n      }\n      else {\n        ret.push({ steps: [[steps,edo]], diff: useExactDiffs ? diff : diff.toCents() });\n        last_diff = abs_diff;\n        if (last_diff.equals(1)) { foundExact = true };\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * Finds best EDO step approximations of the given interval, sorted by error.\n  *\n  * @param {Interval} i\n  * @param {Object} [opts]\n  * @param {integer} [opts.startEDO] defaults to 5\n  * @param {integer} [opts.endEDO] defaults to 60\n  * @param {boolean} [opts.useExactDiffs] defaults to false, controls the type\n  *                                       of each 'diff' property\n  * @returns {Array.<{steps: Array, diff: (number|Interval)}>}\n  */\nfunction bestEDOApproxsByDiff(a,b, opts) {\n  // if only two arguments are given, the second one may be `opts`!\n  if (!opts) {\n    if (typeof b == 'object' && b != null) {\n      opts = b;\n      b = undefined;\n    } else {\n      opts = {};\n    }\n  }\n  const intv = Interval(a,b);\n  if (opts == undefined) { opts = {}; }\n  let {startEDO, endEDO, useExactDiffs} = opts;\n  if (startEDO == undefined) { startEDO = 5; }\n  if (endEDO == undefined) { endEDO = 60; }\n\n  let ret = [];\n  for (let edo = startEDO; edo <= endEDO; edo++) {\n    const steps = edoApprox(edo, intv);\n    const diff = intv.div(Interval(2).pow(steps,edo));\n    const abs_diff = diff.compare(1) < 0 ? diff.recip() : diff;\n    const to_add = { steps: [[steps, edo]], diff: diff, abs_diff: abs_diff };\n    let added = false;\n    for (let i = 0; !added && i < ret.length; i++) {\n      if (diff.equals(ret[i].diff)) {\n        ret[i].steps.push([steps,edo]);\n        added = true;\n      }\n      else if (abs_diff.compare(ret[i].abs_diff) < 0) {\n        ret.splice(i, 0, to_add);\n        added = true;\n      }\n    }\n    if (!added) {\n      ret.push(to_add);\n    }\n  }\n\n  return ret.map(x => ({ steps: x.steps, diff: useExactDiffs ? x.diff : x.diff.toCents() }));\n}\n\nmodule.exports.bestRationalApproxs = bestRationalApproxs;\nmodule.exports.bestEDOApproxsByEDO = bestEDOApproxsByEDO;\nmodule.exports.bestEDOApproxsByDiff = bestEDOApproxsByDiff;\n",
    "/**\n * Functions for working with intervals in an EDO\n * @copyright 2021 Matthew Yacavone (matthew [at] yacavone [dot] net)\n * @module edo\n **/\n\nconst {gcd, egcd} = require('mathutils');\nconst Fraction = require('fraction.js');\nconst Interval = require('./interval.js');\nconst py = require('./pythagorean.js');\n\nfunction mod(a,n) {\n  return ((a % n) + n) % n;\n}\n\n/**\n  * Returns the EDO step closest to the given interval\n  *\n  * @param {integer} edo\n  * @param {Interval} i\n  * @returns {integer}\n  */\nfunction edoApprox(edo,a,b) {\n  return Math.round(edo * Interval(a,b).toCents() / 1200);\n}\n\n/**\n  * Returns the EDO step which corresponds to the given pythagorean interval,\n  * where a P5 corresponds to `edoApprox(edo,Interval(3,2))`\n  *\n  * @param {integer} edo\n  * @param {Interval} i\n  * @returns {integer}\n  */\nfunction edoPy(edo,a,b) {\n  const i = Interval(a,b);\n  const g = Fraction(py.pyGenerator(i) * edoApprox(edo,3,2), 4);\n  const v = py.pyOctaves(i);\n  if (g.d != 1) {\n    throw edo + \"-EDO has no \" + py.pySymb(i,{verbosity:1}) + \" interval\"\n  }\n  return g.s*g.n + v * edo;\n}\n\n/**\n  * Returns the pythagorean interval with the smallest generator which\n  * corresponds to the given EDO step, i.e. for which `edoPy` returns the given\n  * EDO step. Note that there may be no such interval, in which case this\n  * function returns `undefined`.\n  *\n  * All other intervals for which `edoPy` returns the given EDO step are\n  * the result of this function times some power of `edoPyComma`.\n  *\n  * In summary, for every pythagorean interval i there exists some integer k\n  * such that `edoPyInv(edo, edoPy(edo, i)) == i.mul(edoPyComma(edo).pow(k))`,\n  * and for all integers n and k, either `edoPyInv(edo, n)` is undefined or\n  * `edoPy(edo, edoPyInv(edo, n).mul(edoPyComma(edo).pow(k))) == n`.\n  *\n  * @param {integer} edo\n  * @param {integer} n\n  * @returns {Interval}\n  */\nfunction edoPyInv(edo,n) {\n  const p5 = edoApprox(edo,3,2);\n  // d == x * p5 + 4 * y * edo\n  const [d, x, y] = egcd(p5, 4 * edo);\n  if ((4 * n) % d == 0) {\n    // n == (g / 4) * p5 + o * edo\n    const [g, o] = [x * (4*n/d), y * (4*n/d)];\n    // n == (g_bal / 4) * p5 + o_bal * edo && -(edo/d)/2 < g_bal/4 <= (edo/d)/2\n    const edo_2d = Math.floor((4*edo/d - 1) / 2);\n    const g_bal = mod(g + edo_2d, 4*edo/d) - edo_2d;\n    const o_bal = o - p5 * ((g_bal - g) / (4 * edo));\n    return Interval(3,2).pow(g_bal,4).mul(Interval(2).pow(o_bal));\n  }\n}\n\n/**\n  * The smallest pythagorean interval tempered out in the given edo (I believe\n  * this is the correct description...)\n  *\n  * @param {integer} edo\n  * @returns {Interval}\n  */\nfunction edoPyComma(edo) {\n  const p5 = edoApprox(edo,3,2);\n  const d = gcd(p5, 4 * edo);\n  return Interval(3,2).pow(-4 * edo / d, 4).mul(Interval(2).pow(p5 / d));\n}\n\n/**\n  * Checks whether neutral pythagorean intervals are realized in the given EDO,\n  * i.e. if `edoApprox(edo,Interval(3,2))` is divisible by 2\n  *\n  * @param {integer} edo\n  * @returns {boolean}\n  */\nfunction edoHasNeutrals(edo) {\n  return edoApprox(edo,3,2) % 2 == 0;\n}\n\n/**\n  * Checks whether semi-neutral pythagorean intervals are realized in the given\n  * EDO, i.e. if `edoApprox(edo,Interval(3,2))` is divisible by 4\n  *\n  * @param {integer} edo\n  * @returns {boolean}\n  */\nfunction edoHasSemiNeutrals(edo) {\n  return edoApprox(edo,3,2) % 4 == 0;\n}\n\n// used in `updnsSymb` and `updnsNote`\nfunction fillGens(edo, g, lo, hi) {\n  let steps = [];\n  for (let i = 0; i < edo; i++) { steps.push(Array(0)); }\n  if (lo <= 0 && 0 <= hi) {\n    steps[0].push(0)\n  }\n  for (let k = 1; k <= Math.max(Math.abs(lo), Math.abs(hi)); k++) {\n    if (lo <=  k &&  k <= hi) { steps[mod( k*g,edo)].push( k); }\n    if (lo <= -k && -k <= hi) { steps[mod(-k*g,edo)].push(-k); }\n  }\n  return steps;\n}\n\n// used in `updnsSymb` and `updnsNote`\nfunction addUpdns(edo, steps) {\n  let new_steps = steps.map(_ => Array(0));\n  let [last_below, last_above] = [0,edo];\n  for (let i = 0; i < edo; i++) {\n    if (steps[i].length == 0) {\n      new_steps[i].push(...steps[last_below].map(k => [i - last_below, k]));\n    }\n    else {\n      new_steps[i].push(...steps[i].map(k => [0,k]));\n      last_below = i;\n    }\n    const j = (edo-1)-i;\n    if (steps[j].length == 0) {\n      new_steps[j].push(...steps[mod(last_above,edo)].map(k => [j - last_above, k]));\n    }\n    else {\n      last_above = j;\n    }\n  }\n  for (let i = 0; i < edo; i++) {\n    let [minUpdns, hasNonNeutral] = [edo, false];\n    for (const [uds, k] of new_steps[i]) {\n      minUpdns = Math.min(minUpdns, Math.abs(uds));\n      hasNonNeutral = hasNonNeutral || Number.isInteger(k);\n    }\n    new_steps[i] = new_steps[i].filter(udsk => Math.abs(udsk[0]) <= minUpdns\n                                               && (!hasNonNeutral || Number.isInteger(udsk[1])))\n                               .sort((a,b) => a[0] == b[0] ? Math.abs(a[1]) - Math.abs(b[1])\n                                                           : b[0] - a[0]);\n  }\n  return new_steps;\n}\n\n// used in `updnsSymb` and `updnsNote`\nfunction cvtGensToPy(edo, steps) {\n  for (let i = 0; i < edo; i++) {\n    for (let j = 0; j < steps[i].length; j++) {\n      let v = Interval(steps[i][j][1] == 0 && steps[i][j][0] < 0 ? 2 : 1);\n      steps[i][j][1] = Interval(3,2).pow(steps[i][j][1]).red().mul(v);\n    }\n  }\n  return steps;\n}\n\nlet upsdnsSymbCache_var = {};\n\nfunction updnsSymbCache(edo) {\n  if (upsdnsSymbCache_var[edo]) {\n    return upsdnsSymbCache_var[edo];\n  }\n  const fifth = edoApprox(edo,3,2);\n  let [lo, hi] = [-6, 6]; // d5 m2 m6 m3 m7 P4 | P1 | P5 M2 M6 M3 M7 A4\n  // Special case for perfect EDOs\n  if (fifth/edo == 4/7) {\n    [lo, hi] = [-1.5, 1.5]; // (~2) P4 (~6) | P1 | (~3) P5 (~7)\n  }\n  // Special case for pentatonic EDOs\n  if (fifth/edo == 3/5) {\n    [lo, hi] = [-4, 4]; // m6 m3 m7 P4 | P1 | P5 M2 M6 M3\n  }\n  let steps;\n  if (fifth % 2 != 0) {\n    steps = fillGens(edo, fifth, lo, hi);\n  } else {\n    steps = fillGens(edo, fifth/2, 2*lo, 2*hi);\n    for (let i = 0; i < edo; i++) {\n      steps[i] = steps[i].filter(k => k % 2 == 0 || Math.abs(k) <= 6).map(k => k/2);\n    }\n  }\n  steps = cvtGensToPy(edo, addUpdns(edo, steps));\n  upsdnsSymbCache_var[edo] = steps;\n  return steps;\n}\n\n/**\n  * Returns the ups-and-downs notation symbol for the given steps in the given\n  * EDO\n  *\n  * @param {integer} edo\n  * @param {integer} n\n  * @returns {string}\n  */\nfunction updnsSymb(edo,n) {\n  const nr = mod(n,edo);\n  const vs = Interval(2).pow(n - nr, edo);\n  const cache = updnsSymbCache(edo)[nr];\n  let ret = [];\n  for (let i = 0; i < cache.length; i++) {\n    const updns = (cache[i][0] > 0 ? '^' : 'v').repeat(Math.abs(cache[i][0]));\n    const str = updns + py.pySymb(cache[i][1].mul(vs));\n    ret.push(str.replace(\"n\",\"~\").replace(\"sA\",\"~\").replace(\"sd\",\"~\"));\n  }\n  return ret;\n}\n\nlet upsdnsNoteCache_var = {};\n\nfunction updnsNoteCache(edo) {\n  if (upsdnsNoteCache_var[edo]) {\n    return upsdnsNoteCache_var[edo];\n  }\n  const fifth = edoApprox(edo,3,2);\n  let [lo, hi] = [-9, 7]; // Gb Db Ab Eb Bb F C G D | A | E B F# C# G# D# A#\n  // Special case for perfect EDOs\n  if (fifth/edo == 4/7) {\n    [lo, hi] = [-4, 2]; // F C G D | A | E B\n  }\n  // Special case for EDOs between perfect and 12-EDO\n  if (fifth/edo > 4/7 && fifth/edo < 7/12) {\n    [lo, hi] = [-11, 9]; // Fb Cb Gb ... | A | ... A# E# B#\n  }\n  const steps = cvtGensToPy(edo, addUpdns(edo, fillGens(edo, fifth, lo, hi)));\n  upsdnsNoteCache_var[edo] = steps;\n  return steps;\n}\n\n/**\n  * Returns the ups-and-downs notation note name for the given steps to A4 in\n  * the given EDO. The returned string uses ASCII instead of uniode wherever\n  * possible iff the third argument is given and is true\n  *\n  * @param {integer} edo\n  * @param {integer} n\n  * @param {Boolean} [useASCII=false]\n  * @returns {string}\n  */\nfunction updnsNote(edo, n, useASCII) {\n  const nr = mod(n,edo);\n  const vs = Interval(2).pow(n - nr, edo);\n  const cache = updnsNoteCache(edo)[nr];\n  let ret = [];\n  for (let i = 0; i < cache.length; i++) {\n    const updns = (cache[i][0] > 0 ? '^' : 'v').repeat(Math.abs(cache[i][0]));\n    const str = updns + py.pyNote(cache[i][1].mul(vs), useASCII);\n    ret.push(str);\n  }\n  return ret;\n}\n\nmodule['exports'].edoApprox = edoApprox;\nmodule['exports'].edoPy = edoPy;\nmodule['exports'].edoPyInv = edoPyInv;\nmodule['exports'].edoPyComma = edoPyComma;\nmodule['exports'].edoHasNeutrals = edoHasNeutrals;\nmodule['exports'].edoHasSemiNeutrals = edoHasSemiNeutrals;\nmodule['exports'].updnsSymbCache = updnsSymbCache;\nmodule['exports'].updnsSymb = updnsSymb;\nmodule['exports'].updnsNoteCache = updnsNoteCache;\nmodule['exports'].updnsNote = updnsNote;\n",
    "/**\n * English names for intervals based on the Neutral FJS and ups-and-downs\n * notations (very much incomplete!)\n * @copyright 2021 Matthew Yacavone (matthew [at] yacavone [dot] net)\n * @module english\n **/\n\nconst pf = require('primes-and-factors');\nconst Fraction = require('fraction.js');\nconst Interval = require('./interval.js');\nconst {pySymb, pyGenerator} = require('./pythagorean.js');\nconst {fjsFifthShift, fjsAccidentals, nfjsParams} = require('./fjs.js');\nconst {updnsSymbCache} = require('./edo.js');\n\nconst primeNames = { '5':  [\"classic\", \"cls.\"]\n                   , '7':  [\"septimal\", \"sep.\"]\n                   , '11': [\"undecimal\", \"und.\"]\n                   , '13': [\"tridecimal\", \"trid.\"]\n                   , '17': [\"septendecimal\", \"sepd.\"]\n                   , '19': [\"undevicesimal\", \"undv.\"] };\n\n/**\n  * Attempts to give english names to the given interval based on the\n  * Neutral FJS and ups-and-downs notations.\n  *\n  * @param {Interval} i\n  * @param {{abbreviate: boolean, prefEDO: }=} opts\n  * @returns {Array.<string>}\n  */\nfunction enNames(a,b, opts) {\n  // if only two arguments are given, the second one may be `opts`!\n  if (!opts && typeof b == 'object' && b != null) {\n      opts = b;\n      b = undefined;\n  }\n  const intv = Interval(a,b);\n  const abbreviate = (opts || {}).abbreviate ? 1 : 0;\n  const verbosity  = abbreviate ? 1 : 2;\n  const prefEDO    = (opts || {}).prefEDO;\n\n  let nms = [];\n\n  // random special cases\n  if (intv.equals(Interval(2).sqrt())) {\n    nms.push(\"tritone\");\n  }\n\n  // Neutral FJS intervals\n  const fjs = fjsAccidentals(a,b, nfjsParams);\n  if (fjs) {\n    let pyi_symb = pySymb(fjs.pyi, {verbosity: verbosity});\n    const resFact = Object.entries(intv).filter(pe => pe[0] > 3);\n    // FJS intervals with no accidentials and a factor of 3 are Pythagorean\n    if (resFact.length == 0) {\n      if (intv['3'] && (intv['3'].d != 1 || intv['3'].n > 1)) {\n        nms.push((abbreviate ? \"py. \" : \"pythagorean \") + pyi_symb);\n      }\n      else {\n        nms.push(pyi_symb);\n      }\n    }\n    // FJS intervals with a single prime (>3) factor might be able to be named\n    else if (resFact.length == 1) {\n      const [p,e] = resFact[0];\n      // We don't consider cases where the prime doesn't have the name, the FJS\n      //  accidental is not an integer, or the pythagorean interval is an\n      //  octave\n      if (primeNames[p] && e.d == 1 && pyGenerator(fjs.pyi) != 0) {\n        const fifthShift = fjsFifthShift(p, nfjsParams);\n        const g = fjs.pyi['3'] || Fraction(0);\n        // Ensure otonality matches (e.g. let through \"M3^5\" but not \"M3_5\")\n        //  and neutral-ness matches (e.g. let through \"M3^1\" but not \"n3^5\")\n        if (e.s == fifthShift.s * g.s && g.d == fifthShift.d) {\n          // Ensure multiplicity matches, i.e. n-aug/dim have (n+1) primes\n          //  (e.g. let through M3^5 and A4^5,5 but not M3^5,5 or A4^5)\n          let multiplicityMatches = false;\n          // Well, for primes with non-neutral fifth shifts, we do exactly\n          //  what's stated above...\n          if (fifthShift.d == 1) {\n            if (g.n == 6) {\n              multiplicityMatches = (e.n == 2);\n            }\n            else {\n              multiplicityMatches = (e.n == 2 + Math.floor((g.n - 6)/7))\n            }\n          }\n          // ...but for primes with neutral fifth shifts, we just handle cases\n          //  where the neutral interval is small, since it's not clear to me\n          //  what to do in the general case\n          if (fifthShift.d == 2) {\n            multiplicityMatches = (g.n <= 11 && e.n == 1);\n          }\n          if (multiplicityMatches) {\n            // make sure we don't have \"perfect\" in the name for a 4th or 5th\n            if (Math.abs(pyGenerator(fjs.pyi)) == 4) {\n              const typ = intv.compare(fjs.pyi) > 0 ? \"super\" : \"sub\";\n              if (abbreviate) { pyi_symb = pyi_symb.replace(\"perfect\", typ); }\n              else { pyi_symb = pyi_symb.replace(\"perfect \", typ + \"-\"); }\n            }\n            nms.push(primeNames[p][abbreviate] + \" \" + pyi_symb.replace(\"perfect \", \"\"));\n          }\n        }\n      }\n    }\n  }\n\n  // ups-and-downs intervals\n  else if (Object.entries(intv).length == (intv['2'] != null)) {\n    const e2 = intv['2'] || Fraction(0);\n    const edo = prefEDO ? prefEDO : e2.d;\n    const edo_str = edo + \"-EDO \";\n    let intv_strs = [];\n    if (e2.mul(edo).d == 1 && (prefEDO || edo <= 60)) {\n      const n = e2.s * e2.mul(edo).n;\n      const n_mod = ((n % edo) + edo) % edo;\n      for (const [uds, pyi] of updnsSymbCache(edo)[n_mod]) {\n        let uds_str = \"\";\n        if      (uds ==  1) { uds_str = \"up\"; }\n        else if (uds == -1) { uds_str = \"down\"; }\n        else if (uds ==  2 && !abbreviate) { uds_str = \"double-up \"; }\n        else if (uds == -2 && !abbreviate) { uds_str = \"double-down \"; }\n        else if (uds >=  2) { uds_str = uds + \"-up \"; }\n        else if (uds <= -2) { uds_str = uds + \"-down \"; }\n        let pyi_symb = pySymb(pyi, {verbosity: verbosity});\n        if (abbreviate) { pyi_symb = pyi_symb.replace(\"perfect\", \"\"); }\n        else { pyi_symb = pyi_symb.replace(\"perfect \", \"-\"); }\n        intv_strs.push(uds_str + pyi_symb);\n      }\n      nms.push(edo_str + intv_strs.join(\" / \"));\n    }\n  }\n\n  return nms;\n}\n\nmodule.exports.enNames = enNames;\n",
    "/**\n * Functions for working with FJS intervals\n * @copyright 2021 Matthew Yacavone (matthew [at] yacavone [dot] net)\n * @module fjs\n **/\n\nconst pf = require('primes-and-factors');\nconst Fraction = require('fraction.js');\nconst Interval = require('./interval.js');\nconst py = require('./pythagorean.js');\n\n/**\n  * The radius of tolerance of the FJS, the interval `65/63` (about `54.11c`)\n  *\n  * @constant {Interval}\n  */\nconst fjsRoT = Interval(65,63);\n\n/**\n  * The (infinite) fifths sequence of the FJS, `0, 1, -1, 2, -2, 3, -3, ...`\n  *\n  * @yields {Fraction}\n  */\nfunction* fjsFifthsSeq() {\n  yield 0;\n  for (let g = 1; true; g++) {\n    yield Fraction(g);\n    yield Fraction(-g);\n  }\n}\n\n/**\n  * The parameters of the FJS, `fjsRoT`, `fjsFifthsSeq`, and\n  * `hasNeutrals = false`\n  *\n  * @constant {{RoT: Fraction, fifthSeq: Fraction, hasNeutrals: boolean}}\n  */\nconst fjsParams = { RoT: fjsRoT, fifthsSeq: fjsFifthsSeq, hasNeutrals: false };\n\n/**\n  * The radius of tolerance of the Neutral FJS, a pythagorean\n  * semi-diminished second (\"sd2\", the interval exactly halfway between a\n  * pythagorean \"d2\" and \"m2\", or about `33.38c`)\n  *\n  * @constant {Interval}\n  */\nconst nfjsRoT = py.pyInterval(2,-1); // \"sd2\" ~= 33.38c\n\n/**\n  * The (finite) fifths sequence of the Neutral FJS,\n  * `0, 1, -1, 2, -2, ..., 6, -6, 1/2, -1/2, 3/2, -3/2, ..., 11/2, -11/2`\n  *\n  * @yields {Fraction}\n  */\nfunction* nfjsFifthsSeq() {\n  yield 0;\n  for (let g = 1; g <= 6; g++) {\n    yield Fraction(g);\n    yield Fraction(-g);\n  }\n  for (let g = 1; g < 6; g++) {\n    yield Fraction(2*g-1, 2);\n    yield Fraction(1-2*g, 2);\n  }\n}\n\n/**\n  * The parameters of the Neutral FJS, `nfjsRoT`, `nfjsFifthsSeq`, and\n  * `hasNeutrals = true`\n  *\n  * @constant {{RoT: Fraction, fifthSeq: Fraction, hasNeutrals: boolean}}\n  */\nconst nfjsParams = { RoT: nfjsRoT, fifthsSeq: nfjsFifthsSeq, hasNeutrals: true };\n\n/**\n  * Returns the FJS fifth shift associated to any interval.\n  *\n  * @param {Interval} i\n  * @param {{RoT: Fraction, fifthSeq: Fraction}} [params=fjsParams]\n  * @returns {Fraction}\n  */\nfunction fjsFifthShift(a,b, params) {\n  // if only two arguments are given, the second one may be `params`!\n  if (!params) {\n    if (typeof b == 'object' && b != null) {\n      params = b;\n      b = undefined;\n    } else {\n      params = fjsParams;\n    }\n  }\n  const intv = Interval(a,b);\n  const fifthsSeqGen = params.fifthsSeq();\n  for (const g of fifthsSeqGen) {\n    let c = intv.div(Interval(3,2).pow(g)).reb();\n    if (c.compare(params.RoT) < 0 && params.RoT.recip().compare(c) < 0) {\n      return g;\n    }\n  }\n}\n\n/**\n  * Returns the FJS comma associated to a prime interval greater than 3\n  * (i.e. 5, 7, 11, etc.)\n  *\n  * @param {integer} p\n  * @param {{RoT: Fraction, fifthSeq: Fraction}} [params=fjsParams]\n  * @returns {Interval}\n  */\nfunction fjsComma(p, params) {\n  if (!params) { params = fjsParams; }\n  p = parseInt(p);\n  if (!pf.isPrime(p) || p <= 3) {\n    throw \"input is not a prime interval greater than 3\";\n  }\n  const fifthsSeqGen = params.fifthsSeq();\n  for (const g of fifthsSeqGen) {\n    let c = Interval(p).div(Interval(3,2).pow(g)).reb();\n    if (c.compare(params.RoT) < 0 && params.RoT.recip().compare(c) < 0) {\n      return c;\n    }\n  }\n}\n\n/**\n  * Given an interval, returns the product of the FJS commas associated to each\n  * of its prime factors raised to the exponents of those prime factors\n  *\n  * @param {Interval} k\n  * @param {{RoT: Fraction, fifthSeq: Fraction}} [params=fjsParams]\n  * @returns {Interval}\n  */\nfunction fjsFactor(a,b, params) {\n  // if only two arguments are given, the second one may be `params`!\n  if (!params) {\n    if (typeof b == 'object' && b != null) {\n      params = b;\n      b = undefined;\n    } else {\n      params = fjsParams;\n    }\n  }\n  const k = Interval(a,b);\n  let ret = Interval(1);\n  for (const [p,e] of Object.entries(k)) {\n    ret = ret.mul(fjsComma(p,params).pow(e));\n  }\n  return ret;\n}\n\n/**\n  * Returns the string of FJS accidentals for the given interval, as well as\n  * the pythagorean interval which when applied to these accidentals\n  * results in the given interval.\n  *\n  * @param {Interval} i\n  * @param {{RoT: Fraction, fifthSeq: Fraction}} [params=fjsParams]\n  * @returns {{ accStr: string, pyi: Interval }}\n  */\nfunction fjsAccidentals(a,b, params) {\n  // if only two arguments are given, the second one may be `params`!\n  if (!params) {\n    if (typeof b == 'object' && b != null) {\n      params = b;\n      b = undefined;\n    } else {\n      params = fjsParams;\n    }\n  }\n  const i = Interval(a,b);\n  let pyi = i;\n  let otos = [];\n  let utos = [];\n  for (let [p,e] of Object.entries(i)) {\n    if (p != 2 && p != 3) {\n      pyi = pyi.div(fjsComma(p,params).pow(e));\n      // add otonal accidentals\n      while (e >= 1) {\n        otos.push(p);\n        e = e.sub(1);\n      }\n      if (e > 0 && e.d == 2) {\n        otos.push(\"sqrt(\" + p + \")\");\n      }\n      if (e > 0 && e.d > 2) {\n        otos.push(\"root\" + e.d + \"(\" + p + \")\");\n      }\n      // add utonal accidentals\n      while (e <= -1) {\n        utos.push(p);\n        e = e.add(1);\n      }\n      if (e < 0 && e.d == 2) {\n        utos.push(\"sqrt(\" + p + \")\");\n      }\n      if (e < 0 && e.d > 2) {\n        utos.push(\"root\" + e.d + \"(\" + p + \")\");\n      }\n    }\n  }\n  const modulus = params.hasNeutrals ? 2 : 4;\n  if (py.isPythagorean(pyi) && py.pyGenerator(pyi) % modulus == 0) {\n    const otoStr = otos.length == 0 ? \"\" : \"^\" + otos.join(\",\");\n    const utoStr = utos.length == 0 ? \"\" : \"_\" + utos.join(\",\");\n    return { accStr: otoStr + utoStr, pyi: pyi };\n  }\n}\n\n/**\n  * Returns the FJS symbol of the given interval, or undefined if no such symbol\n  * exists\n  *\n  * @param {Interval} i\n  * @param {{RoT: Fraction, fifthSeq: Fraction}} [params=fjsParams]\n  * @returns {string}\n  */\nfunction fjsSymb(a,b, params) {\n  const res = fjsAccidentals(a,b, params);\n  if (res) {\n    return py.pySymb(res.pyi) + res.accStr;\n  }\n}\n\n/**\n  * Returns the FJS note name of the given interval to A4, or undefined if no\n  * such name exists\n  *\n  * @param {Interval} i\n  * @param {{RoT: Fraction, fifthSeq: Fraction}} [params=fjsParams]\n  * @returns {string}\n  */\nfunction fjsNote(a,b, params) {\n  const res = fjsAccidentals(a,b, params);\n  if (res) {\n    return py.pyNote(res.pyi) + res.accStr;\n  }\n}\n\nmodule['exports'].fjsRoT = fjsRoT;\nmodule['exports'].fjsFifthsSeq = fjsFifthsSeq;\nmodule['exports'].fjsParams = fjsParams;\nmodule['exports'].nfjsRoT = nfjsRoT;\nmodule['exports'].nfjsFifthsSeq = nfjsFifthsSeq;\nmodule['exports'].nfjsParams = nfjsParams;\nmodule['exports'].fjsFifthShift = fjsFifthShift;\nmodule['exports'].fjsComma = fjsComma;\nmodule['exports'].fjsFactor = fjsFactor;\nmodule['exports'].fjsAccidentals = fjsAccidentals;\nmodule['exports'].fjsSymb = fjsSymb;\nmodule['exports'].fjsNote = fjsNote;\n",
    "// export everything\nmodule['exports']['Interval'] = require('./interval.js');\nObject.assign(module['exports'], require('./pythagorean.js'));\nObject.assign(module['exports'], require('./fjs.js'));\nObject.assign(module['exports'], require('./edo.js'));\nObject.assign(module['exports'], require('./approx.js'));\nObject.assign(module['exports'], require('./english.js'));\nObject.assign(module['exports'], require('./parser.js'));\n",
    "/**\n * The interval datatype, based on `Fraction` from `fraction.js` on npm\n * @copyright 2021 Matthew Yacavone (matthew [at] yacavone [dot] net)\n * @module interval\n **/\n\nconst pf = require('primes-and-factors');\nconst Fraction = require('fraction.js');\n\nconst keys = function(a, b) {\n  let ret = {};\n  for (const [k,v] of Object.entries(a)) {\n    ret[k] = 1;\n  }\n  if (b) {\n    for (const [k,v] of Object.entries(b)) {\n      ret[k] = 1;\n    }\n  }\n  return ret;\n}\n\nconst parse = function(a, b) {\n  if (a === undefined || a === null) {\n    return {};\n  }\n  else if (b !== undefined) {\n    if (a == 0 || a < 0 || b == 0 || b < 0) {\n      throw \"non-positive number cannot be converted into an interval\"\n    }\n    const afs = pf.getPrimeExponentObject(a);\n    const bfs = pf.getPrimeExponentObject(b);\n    let ret = keys(afs,bfs);\n    for (const i in ret) {\n      ret[i] = Fraction((afs[i] || 0) - (bfs[i] || 0));\n    }\n    return ret;\n  }\n  else if (typeof a == \"object\") {\n    if (\"d\" in a && \"n\" in a) {\n      let sn = a[\"n\"];\n      if (\"s\" in a) {\n        sn *= a[\"s\"];\n      }\n      return parse(sn, a[\"d\"]);\n    }\n    else {\n      let allPrimes = true\n      let ret = {};\n      for (const i in keys(a)) {\n        allPrimes &= pf.isPrime(Number(i));\n        if (Fraction(a[i]) != 0) {\n          ret[i] = Fraction(a[i]);\n        }\n      }\n      if (allPrimes) {\n        return ret;\n      } else {\n        throw \"argument is not a number, fraction, or interval\"\n      }\n    }\n  }\n  else {\n    return parse(Fraction(a));\n  }\n}\n\n/**\n  * Constructs an `Interval`. Valid argument combinations are two integers\n  * (e.g. `Interval(3,2)`), a single number (e.g. `Interval(3/2)`), an array\n  * containing 0-2 integers (e.g. `Interval([3,2])`), a factorization\n  * (e.g. `Interval({2: -1, 3: 1})`), a `Fraction`, or an `Interval`.\n  *\n  * As a convention, all functions which have a JSDoc parameter of type\n  * `Interval` should be able to accept any of these argument combinations in\n  * place of that parameter. For example, `mul` in this file, or\n  * `bestRationalApproxs` in `approx.js`.\n  *\n  * If both arguments are omitted, the result is `Interval(1)`.\n  *\n  * @constructor\n  * @param {(number|Fraction|Object)=} a\n  * @param {integer=} b\n  */\nfunction Interval(a,b) {\n\n  if (!(this instanceof Interval)) {\n    return new Interval(a,b);\n  }\n\n  const p = parse(a,b);\n  for (const i in keys(p)) {\n    this[i] = p[i]\n  }\n\n}\n\nInterval.prototype = {\n\n  /**\n   * Multiplies (i.e. composes) two intervals.\n   *\n   * e.g. `Interval(3,2).mul(5,4)` is the composition of `3/2` and `5/4`, the\n   * interval `15/8`, or `Interval(15,8)`\n   *\n   * @param {Interval} i\n   * @returns {Interval}\n   */\n  \"mul\": function(a,b) {\n    const rhs = parse(a,b);\n    let ret = keys(this,rhs);\n    for (const i in ret) {\n      ret[i] = (this[i] || Fraction(0)).add(rhs[i] || Fraction(0));\n    }\n    return new Interval(ret);\n  },\n\n  /**\n   * Divides two intervals.\n   *\n   * e.g. `Interval(2).div(3,2)` is exactly `Interval(4,3)`\n   *\n   * @param {Interval} i\n   * @returns {Interval}\n   */\n  \"div\": function(a,b) {\n    const rhs = parse(a,b);\n    let ret = keys(this,rhs);\n    for (const i in ret) {\n      ret[i] = (this[i] || Fraction(0)).sub(rhs[i] || Fraction(0));\n    }\n    return new Interval(ret);\n  },\n\n  /**\n   * Takes the reciprocal/inverse of an interval.\n   *\n   * e.g. `Interval(3,2).recip()` is exactly `Interval(2,3)`\n   *\n   * @returns {Interval}\n   */\n  \"recip\": function() {\n    let ret = keys(this);\n    for (const i in ret) {\n      ret[i] = this[i].neg();\n    }\n    return new Interval(ret);\n  },\n\n  /**\n   * Raises an interval to a fractional power.\n   *\n   * e.g. `Interval(4,3).pow(2)` is the composition of `4/3` with itself, the\n   * interval `16/9`\n   *\n   * e.g. `Interval(2).pow(4,12)` is the interval `4\\12`, four steps of 12-EDO\n   *\n   * e.g. `Interval(5).pow(1,4)` is the fourth root of `5`, the fifth in\n   * quarter-comma meantone\n   *\n   * @param {Fraction} k\n   * @returns {Interval}\n   */\n  \"pow\": function(a,b) {\n    let ret = keys(this);\n    for (const i in ret) {\n      ret[i] = this[i].mul(Fraction(a,b));\n    }\n    return new Interval(ret);\n  },\n\n  /**\n   * The nth root of an interval, i.e. `pow(1,n)`.\n   *\n   * @param {integer} n\n   * @returns {Interval}\n   */\n  \"root\": function(a) {\n    return this.pow(Fraction(1,a));\n  },\n\n  /**\n   * The square root of an interval, i.e. `pow(1,2)`.\n   *\n   * @returns {Interval}\n   */\n  \"sqrt\": function() {\n    return this.pow(1/2);\n  },\n\n  /**\n   * Checks whether an interval has integer prime exponents, i.e. whether the\n   * interval can be expressed as a fraction\n   *\n   * e.g. `Interval(3,2).isFrac()` returns `true`\n   *\n   * e.g. `Interval(2).sqrt().isFrac()` returns `false`\n   *\n   * @returns {bool}\n   */\n  \"isFrac\": function() {\n    for (const i in keys(this)) {\n      if (this[i].d != 1) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  /**\n   * Converts an interval with integer prime exponents, i.e. an interval which\n   * can be expressed as a fraction, to a `Fraction`.\n   *\n   * e.g. `Interval(3,2).toFrac()` is exactly `Fraction(3,2)`\n   *\n   * e.g. `Interval(2).sqrt().toFrac()` throws an error\n   *\n   * @returns {Fraction}\n   */\n  \"toFrac\": function() {\n    let ret = Fraction(1);\n    for (const i in keys(this)) {\n      if (this[i].d == 1) {\n        ret = ret.mul(Fraction(i).pow(this[i].s * this[i].n));\n      } else {\n        throw \"interval does not have integer exponents\";\n      }\n    }\n    return ret;\n  },\n\n  /**\n   * Takes the mediant of two intervals with integer prime exponents, i.e. two\n   * intervals which can be expressed as fractions.\n   *\n   * e.g. `Interval(5,4).med(9,7)` is the mediant of the intervals `5/4` and\n   * `9/7`, the interval `14/11`\n   *\n   * @returns {Interval}\n   */\n  \"med\": function(a,b) {\n    let [f1, f2] = [this.toFrac(), Interval(a,b).toFrac()];\n    return new Interval(f1.n + f2.n, f1.d + f2.d);\n  },\n\n  /**\n   * Converts any interval to its representation as the nth root of a fraction.\n   *\n   * e.g. `Interval(3,2).toNthRoot()` is exactly `{k: Interval(3,2), n: 1}`\n   *\n   * e.g. `Interval({2: 1/2, 5: 1/3})` is exactly `{k: Interval({2: 3, 5: 2}), n: 6}`\n   *\n   * @returns {{k: Fraction, n: Integer}}\n   */\n  \"toNthRoot\": function() {\n    let n_fr = Fraction(1);\n    for (const i in keys(this)) {\n      n_fr = n_fr.gcd(this[i]);\n    }\n    return { k: this.pow(n_fr.inverse()).toFrac(), n: n_fr.d };\n  },\n\n  /**\n   * Converts an interval to its decimal value, for automatic use by javascript.\n   * Note that this function should not be used to compare relative sizes of\n   * intervals, use `valueOf_log` or `toCents` instead.\n   *\n   * e.g. `Interval(3,2).valueOf()` is exactly `1.5`\n   *\n   * @returns {number}\n   */\n  \"valueOf\": function() {\n    let ret = 1;\n    for (const i in keys(this)) {\n      ret *= Math.pow(i,this[i].valueOf())\n    }\n    return ret;\n  },\n\n  /**\n   * Performs an exact comparison of two intervals. Specifically, returns 0 if\n   * the intervals are equal, 1 if the first interval is greater than the\n   * second, and -1 if the second interval is greater than the first.\n   *\n   * In general, `i1 ineq i2`, where `i1`, `i2` are intervals and `ineq` is an\n   * inequality (e.g. `>=`), can be incorrect since javascript uses `valueOf`\n   * to convert both sides to finite precision floating point numbers before\n   * doing the comparision. To perform an exact version of the same check,\n   * use `i1.compare(i2) ineq 0`.\n   *\n   * e.g. `Interval(2).sqrt().compare(3,2) < 0` is true since `sqrt(2) < 3/2`\n   *\n   * @param {Interval} i\n   * @returns {integer}\n   */\n  \"compare\": function(a,b) {\n    const diff = this.div(a,b);\n    const {k,n} = diff.toNthRoot();\n    if (isFinite(k.n) && isFinite(k.d)) {\n      // do an exact comparison if k is finite\n      return k.compare(Fraction(1));\n    }\n    else {\n      // otherwise the numbers are just too big - for now we approximate\n      return (1 < diff.valueOf()) - (diff.valueOf() < 1);\n    }\n  },\n\n  /**\n   * Checks if the two intervals are the same. In general, `i1 == i2`, where\n   * `i1`, `i2` are intervals, can give false positives since javascript uses\n   * `valueOf` to convert both sides to finite precision floating point numbers\n   * before doing the comparision.\n   *\n   * e.g. `Interval(4,3).pow(2).equals(16,9)` is true\n   *\n   * @param {Interval} i\n   * @returns {boolean}\n   */\n  \"equals\": function(a,b) {\n    return this.compare(a,b) == 0;\n  },\n\n  /**\n   * If the given argument is a prime, returns a pair whose first element is the\n   * exponent of that prime in this interval, and whose second element is the\n   * interval without that prime (i.e. the rest of the factorization).\n   *\n   * e.g. `Interval(8*5,7).factorOut(2)` is exactly `[3, Interval(5,7)]`.\n   *\n   * More generally, if the given argument is an interval `i` with factorization\n   * `p1^e1 ... pm^em` (where the `pk`s are prime and in ascending order, and\n   * each `ek > 0`), returns a pair `[g, this.div(i.pow(g))]` where `g` is the\n   * smallest fraction such that `this.div(i.pow(g))` contains no factors of\n   * `pm` (the largest prime in the factorization of `i`).\n   *\n   * e.g. `Interval(9,8).factorOut(3,2)` is exactly `[2, Interval(1,2)]`.\n   *\n   * @param {Interval} i\n   * @returns {Pair.<Fraction,Interval>}\n   */\n  \"factorOut\": function(a,b) {\n    const base = new Interval(a,b);\n    const gp = Math.max(...Object.keys(base));\n    if (isFinite(gp)) {\n      const g = (this[gp] || Fraction(0)).div(base[gp]);\n      let res = keys(this, base);\n      for (const i in res) {\n        res[i] = (this[i] || Fraction(0)).sub((base[i] || Fraction(0)).mul(g));\n      }\n      return [g, new Interval(res)];\n    }\n    else {\n      return [Fraction(0), this];\n    }\n  },\n\n  /**\n   * Converts an interval to its decimal value log the given base. If no\n   * argument is given, the base is taken to be 2 (an octave).\n   *\n   * e.g. `Interval(3,2).valueOf_log()` gives `0.5849625007211561`\n   *\n   * Note that this function uses `factorOut` to preserve as much precision as\n   * possible - for example, for any interval `i` and fraction `k`, then\n   * `i.pow(k).valueOf_log(i) == k` *exactly*.\n   *\n   * e.g. `Interval(3,2).pow(1,2).valueOf_log(3,2)` gives `0.5`\n   *\n   * @param {Interval} [i=Interval(2)]\n   * @returns {number}\n   */\n  \"valueOf_log\": function(a,b) {\n    let base = new Interval(2);\n    if (a != undefined || b != undefined) {\n      base = new Interval(a,b);\n    }\n    const [g, res] = this.factorOut(base);\n    return g + Math.log(res.valueOf()) / Math.log(base.valueOf());\n  },\n\n  /**\n   * Reduces an interval w.r.t. another interval. If no argument is given, it\n   * is taken to be 2 (an octave).\n   *\n   * e.g. `Interval(3,2).pow(2).red()` is exactly `Interval(9,8)`\n   *\n   * For all intervals `i`, `j` this function satisfies the equality:\n   * `i.div(i.red(j)).equals(j.pow(Math.floor(i.valueOf_log(j))))`\n   *\n   * @param {Interval} [i=Interval(2)]\n   * @returns {Interval}\n   */\n  \"red\": function(a,b) {\n    let base = new Interval(2);\n    if (a != undefined || b != undefined) {\n      base = new Interval(a,b);\n    }\n    const e = Math.floor(this.valueOf_log(base));\n    return this.div(base.pow(e));\n  },\n\n  /**\n   * Balanced reduces an interval w.r.t. another interval. If no argument is\n   * given, the it is taken to be 2 (an octave).\n   *\n   * e.g. `Interval(3,2).reb()` is exactly `Interval(2,3)`\n   *\n   * For all intervals `i`, `j` this function satisfies the equality:\n   * `i.div(i.reb(j)).equals(j.pow(Math.round(i.valueOf_log(j))))`\n   *\n   * @param {Interval} [i=Interval(2)]\n   * @returns {Interval}\n   */\n  \"reb\": function(a,b) {\n    let base = new Interval(2);\n    if (a != undefined || b != undefined) {\n      base = new Interval(a,b);\n    }\n    const e = Math.round(this.valueOf_log(base));\n    return this.div(base.pow(e));\n  },\n\n  /**\n   * Converts an interval to its value in cents.\n   *\n   * e.g. `Interval(3,2).toCents()` gives `701.9550008653873`\n   *\n   * Note that this function uses `factorOut` to preserve as much precision as\n   * possible - for example, for any fraction `k`,\n   * `Interval(2).pow(k).toCents() == k.mul(1200)` *exactly*.\n   *\n   * e.g. `Interval(2).pow(4,12).toCents()` is exactly `400`\n   *\n   * @returns {number}\n   */\n  \"toCents\": function() {\n    const [e2, res] = this.factorOut(2);\n    return e2.mul(1200) + Math.log(res.valueOf()) / Math.log(2) * 1200;\n  },\n\n  /**\n   * Converts an interval to its Tenney harmonic distance, or Tenney height.\n   *\n   * e.g. `Interval(3,2).tenneyHD()` gives `2.584962500721156`\n   *\n   * @returns {number}\n   */\n  \"tenneyHD\": function() {\n    let ret = Interval(1);\n    for (const i in keys(this)) {\n      ret[i] = this[i].abs();\n    }\n    return ret.valueOf_log();\n  },\n\n  /**\n   * Converts an interval to a monzo.\n   *\n   * e.g. `Interval(11,9).toMonzo()` gives `[0,-2,0,0,1]`\n   *\n   * @returns {number}\n   */\n  \"toMonzo\": function() {\n    let max_p = 0;\n    for (const i in keys(this)) {\n      max_p = Math.max(max_p, i);\n    }\n    let [ret, isFrac] = [[], true];\n    if (2 <= max_p) {\n      ret[0] = this[2] || Fraction(0);\n      isFrac &= !this[2] || this[2].d == 1;\n    }\n    let i = 1;\n    for (let p = 3; p <= max_p; p += 2) {\n      if (pf.isPrime(p)) {\n        ret[i] = this[p] || Fraction(0);\n        isFrac &= !this[p] || this[p].d == 1;\n        i++;\n      }\n    }\n    if (isFrac) {\n      ret = ret.map(r => r.s * r.n);\n    }\n    return ret;\n  }\n\n}\n\nmodule.exports = Interval;\n",
    "/**\n * Interface for parsing interval/note expressions\n * @copyright 2021 Matthew Yacavone (matthew [at] yacavone [dot] net)\n * @module parser\n **/\n\nconst ne = require('nearley');\nconst Fraction = require('fraction.js');\nconst Interval = require('./interval.js');\nconst grammar = require('./parser/grammar.js');\nconst {evalExpr} = require('./parser/eval.js');\nconst {isPythagorean, pySymb, pyNote} = require('./pythagorean.js');\nconst {fjsSymb, fjsNote, nfjsParams} = require('./fjs.js');\nconst {edoApprox, edoPy, updnsSymb, updnsNote} = require('./edo.js');\nconst {enNames} = require('./english.js');\n\nfunction mod(a,n) {\n  return ((a % n) + n) % n;\n}\n\nfunction expectedSymbols(parser) {\n  let symbs = [];\n  const lastColumnIndex = parser.table.length - 2;\n  const lastColumn = parser.table[lastColumnIndex];\n  const expectantStates = lastColumn.states\n      .filter(function(state) {\n          var nextSymbol = state.rule.symbols[state.dot];\n          return nextSymbol && typeof nextSymbol !== \"string\";\n      });\n\n  const stateStacks = expectantStates\n      .map(function(state) {\n          return parser.buildFirstStateStack(state, []) || [state];\n      }, parser);\n  // Display each state that is expecting a terminal symbol next.\n  stateStacks.forEach(function(stateStack) {\n      var state = stateStack[0];\n      var nextSymbol = state.rule.symbols[state.dot];\n      var symbolDisplay = parser.getSymbolDisplay(nextSymbol);\n      symbs.push(symbolDisplay);\n  }, parser);\n\n  // remove duplicates\n  symbs = [...new Set(symbs)];\n  symbs.sort((a,b) => a.length - b.length);\n  if (symbs.length > 1) {\n    symbs[symbs.length-1] = \"or \" + symbs[symbs.length-1];\n  }\n  return \"expected a \" + symbs.join(\", \");\n}\n\n/**\n * @typedef {Object} RawParseResult\n * @property {string} type either \"interval\" or \"note\"\n * @property {Interval} intv the resulting interval (to the reference, if\n *                           type is \"note\")\n * @property {{hertz: Interval, intvToA4: Interval}} refNote the reference note\n * @property {integer=} prefEDO the preferred EDO, if any, of the interval\n */\n\n/**\n  * Parses the given string\n  *\n  * @param {string} str\n  * @returns {RawParseResult}\n  */\nfunction parse(str) {\n\n  const parser = new ne.Parser(ne.Grammar.fromCompiled(grammar));\n  try { parser.feed(str); }\n  catch (err) {\n    throw new Error (\"Parse error at col \" + err.offset + \", \" + expectedSymbols(parser));\n  }\n  let results = parser.results;\n\n  for (let i = 0; i < results.length; i++) {\n    const res = evalExpr(results[i].expr, results[i].refNote);\n    results[i].val = res.val;\n    results[i].prefEDO = res.prefEDO;\n  }\n\n  if (results.length == 0) {\n    try { parser.feed(\"$\"); }\n    catch (err) {\n      throw new Error (\"Parse error at col \" + err.offset + \", \" + expectedSymbols(parser));\n    }\n  }\n  if (results.some(d => d.type[0] == \"interval\" && d.type[1] == \"symbol\")) {\n    results = results.filter(d => !(d.type[0] == \"interval\" && d.type[1] != \"symbol\"));\n  }\n  if (results.some(d => d.type[0] == \"note\" && d.type[1] == \"symbol\")) {\n    results = results.filter(d => !(d.type[0] == \"note\" && d.type[1] != \"symbol\"));\n  }\n  if (results.length > 1) {\n    console.log(\"Parse was ambiguous! Full results:\");\n    console.dir(parser.results, { depth: null });\n  }\n  let ret = { type: results[0].type[0]\n            , intv: results[0].val\n            , refNote: results[0].refNote\n            , prefEDO: results[0].prefEDO };\n\n  // If `intv` is an EDO step (i.e. a fractional power of two),\n  if (Object.entries(ret.intv).length == (ret.intv['2'] != null)) {\n    let e2 = ret.intv['2'] || Fraction(0);\n    // forget `ret.prefEDO` if `ret.intv` is not `2^(k/prefEDO)` (sanity check)\n    if (ret.prefEDO && e2.mul(ret.prefEDO).d != 1) {\n      delete ret.prefEDO;\n    }\n    // set `ret.prefEDO` if `ret.intv` is a simple enough power of two\n    if (!ret.prefEDO && (e2.d == 2 || e2.d == 3 || e2.d == 4)) {\n      ret.prefEDO = 12;\n    }\n    if (!ret.prefEDO && 4 < e2.d && e2.d <= 60) {\n      ret.prefEDO = e2.d;\n    }\n  }\n  // Otherwise, forget `ret.prefEDO` (sanity check)\n  else {\n    delete ret.prefEDO;\n  }\n\n  return ret;\n}\n\n/**\n * @typedef {Object} IntvParseResult\n * @property {string} type always \"interval\"\n * @property {number} cents the resulting interval converted to cents\n * @property {Interval} intv the resulting interval object\n * @property {Fraction=} ratio the resulting interval as a JI ratio\n * @property {number=} tenneyHD the Tenney harmonic distance of the resulting\n *                              interval as a JI ratio\n * @property {Pair.<integer,integer>=} edoSteps the resulting interval as some\n *                                              number of EDO steps\n * @property {Object.<string,string>} symb various symbols for the resulting\n *                                         interval, including FJS,\n *                                         Neutral FJS, and ups-and-downs\n *                                         notations\n * @property {Array.<string>} english (experimental) english name for the\n *                                    resulting interval, based on\n *                                    Neutral FJS and ups-and-downs notations\n */\n\n/**\n * @typedef {Object} NoteParseResult\n * @property {string} type always \"note\"\n * @property {number} freq the resulting interval converted to hertz\n * @property {Interval} intvToRef the resulting interval to the reference\n * @property {Pair.<integer,integer>=} edoStepsToRef the resulting interval as\n *                                                   some number of EDO steps\n *                                                   to the reference\n * @property {ReferenceNote} ref the reference note\n * @property {Object.<string,string>} symb various symbols for the resulting\n *                                         interval, including FJS and\n *                                         ups-and-downs notations\n */\n\n/**\n * @typedef {Object} ReferenceNote\n * @property {Interval} hertz\n * @property {Interval} intvToA4\n * @property {Pair.<integer,integer>=} edoStepsToA4\n */\n\n/**\n  * Parses the given string and converts it to a few other convenient forms\n  *\n  * @param {string} str\n  * @returns {IntvParseResult|NoteParseResult}\n  */\nfunction parseCvt(str) {\n  let {type, intv, refNote, prefEDO} = parse(str);\n  let ret = { type: type };\n  if (type == \"interval\") {\n    ret.cents = intv.toCents();\n    ret.intv = intv;\n    try {\n      ret.ratio = intv.toFrac();\n      ret.tenneyHD = intv.tenneyHD();\n    } catch (_) {}\n    if (prefEDO) {\n      let e2 = (intv['2'] || Fraction(0)).mul(prefEDO);\n      ret.edoSteps = [e2.s*e2.n, prefEDO];\n    }\n    ret.symb = {};\n    let fjs = fjsSymb(intv);\n    let nfjs = fjsSymb(intv, nfjsParams);\n    if (fjs) {\n      ret.symb['FJS'] = fjs;\n    }\n    if (nfjs && nfjs != fjs) {\n      ret.symb['Neutral FJS'] = nfjs;\n    }\n    if (prefEDO) {\n      let e2 = (intv['2'] || Fraction(0)).mul(prefEDO);\n      ret.symb['ups-and-downs'] = updnsSymb(prefEDO,e2.s*e2.n).map(s => s + \"\\\\\" + prefEDO);\n    }\n    if (!nfjs && isPythagorean(intv)) {\n      ret.symb['other'] = pySymb(intv);\n    }\n    if (intv.equals(Interval(2).sqrt())) {\n      ret.symb['other'] = \"TT\";\n    }\n    const nms = enNames(intv, {prefEDO: prefEDO});\n    if (nms.length > 0) {\n      ret.english = nms;\n    }\n  }\n  if (type == \"note\") {\n    ret.hertz = refNote.hertz.mul(intv).valueOf();\n    const intvToA4 = intv.mul(refNote.intvToA4);\n    const closest12EDO = edoApprox(12, intvToA4);\n    const diffTo12EDO = intvToA4.div(Interval(2).pow(closest12EDO,12)).toCents();\n    ret.tuningMeter = updnsNote(12, mod(closest12EDO+9,12)-9).join(\"/\") + \" \"\n                      + (diffTo12EDO == 0 ? \"\" : diffTo12EDO > 0 ? \"+\" : \"-\")\n                      + Math.abs(diffTo12EDO).toFixed(1) + \"c\";\n    ret.intvToRef = intv;\n    if (prefEDO) {\n      let e2 = (intv['2'] || Fraction(0)).mul(prefEDO);\n      ret.edoStepsToRef = [e2.s*e2.n, prefEDO];\n    }\n    ret.ref = { hertz: refNote.hertz.valueOf()\n              , intvToA4: refNote.intvToA4 };\n    ret.symb = {};\n\n    let fjs = fjsNote(intvToA4);\n    if (fjs) {\n      ret.symb['FJS'] = fjs;\n    }\n    if (prefEDO) {\n      const refEDOStepsToA4 = edoPy(prefEDO, refNote.intvToA4);\n      ret.ref.edoStepsToA4 = [refEDOStepsToA4, prefEDO];\n      let e2 = (intv['2'] || Fraction(0)).mul(prefEDO).add(refEDOStepsToA4);\n      ret.symb['ups-and-downs'] = updnsNote(prefEDO,e2.s*e2.n).map(s => s + \"\\\\\" + prefEDO);\n    }\n  }\n  return ret;\n}\n\nmodule['exports'].parse = parse;\nmodule['exports'].parseCvt = parseCvt;\n",
    "/**\n * A function for evaluating the results of running `grammar.ne`\n * @copyright 2021 Matthew Yacavone (matthew [at] yacavone [dot] net)\n * @module eval\n **/\n\nconst Fraction = require('fraction.js');\nconst Interval = require('../interval.js');\nconst {pyInterval, isPerfectDeg, baseNoteIntvToA} = require('../pythagorean.js');\nconst {fjsFactor} = require('../fjs.js');\nconst {edoApprox, edoPy, edoHasNeutrals, edoHasSemiNeutrals} = require('../edo.js');\n\nfunction cbnEDOs(a,b) {\n  return a && b ? Fraction(1,a).gcd(1,b).d : undefined\n}\n\n/**\n  * Evaluates the result of running `grammar.ne`\n  *\n  * @param {Array} e the expression to evaluate\n  * @param {{hertz: Interval, intvToA4: Interval}} refNote the reference note\n  * @returns {{val: Interval, prefEDO: integer}}\n  */\nfunction evalExpr(e, r, edo) {\n  if (Array.isArray(e)) {\n    // don't fail in the case of a nested array\n    if (Array.isArray(e[0])) {\n      console.log(\"evalExpr: nested arrays\")\n      return evalExpr(e[0], r, edo);\n    }\n\n    // 1 | Special cases:\n    if (e[0] == \"!refIntvToA4\") {\n      return { val: r.intvToA4 };\n    }\n    if (e[0] == \"!refHertz\") {\n      return { val: r.hertz };\n    }\n    if (e[0] == \"!med\") { // `edo` should be undefined\n      const arg0 = evalExpr(e[1],r).val;\n      const arg1 = evalExpr(e[2],r).val;\n      if (arg0.isFrac() && arg1.isFrac()) {\n        return { val: arg0.med(arg1) };\n      }\n      else {\n        throw \"One of the arguments to `med` is not a fraction\"\n      }\n    }\n    if (e[0] == \"!cents\") { // `edo` should be undefined\n      const arg0 = Fraction(evalExpr(e[1],r).val).div(1200);\n      return { val: Interval(2).pow(arg0)\n             , prefEDO: 48 % arg0.d == 0 ? 24 % arg0.d == 0 ? 12 % arg0.d == 0 ? 12 : 24 : 48 : undefined };\n    }\n    if (e[0] == \"!edoApprox\") { // `edo` should not be defined\n      const arg0 = evalExpr(e[1],r).val;\n      const arg1 = evalExpr(e[2],r).val;\n      return { val: Interval(2).pow(edoApprox(arg1, arg0)).pow(1,arg1), prefEDO: arg1 };\n    }\n    if (e[0] == \"!inEDO\") { // `edo` should be undefined\n      const arg1 = evalExpr(e[2],r).val;\n      const arg0 = evalExpr(e[1],r,arg1).val;\n      return { val: Interval(2).pow(arg0).pow(1,arg1), prefEDO: arg1 };\n    }\n    if (e[0] == \"!edoTT\") { // `edo` should be defined\n      if (edo % 2 == 0) {\n        return { val: edo / 2 };\n      }\n      else {\n        throw edo + \"-EDO does not have a tritone\";\n      }\n    }\n    if (e[0] == \"!edoPy\") { // `edo` should be defined\n      const arg0 = evalExpr(e[1],r,edo).val;\n      return { val: edoPy(edo, arg0) };\n    }\n\n    // for the remaining cases, we evaluate every argument\n    const args = e.slice(1).map(ei => evalExpr(ei,r,edo));\n\n    // 2 | Operators:\n    if (e[0] == \"+\") { return { val: args[0].val + args[1].val }; }\n    if (e[0] == \"-\") { return { val: args[0].val - args[1].val }; }\n    if (e[0] == \"*\") { return { val: args[0].val * args[1].val }; }\n    if (e[0] == \"/\") { return { val: args[0].val / args[1].val }; }\n\n    // 3 | Otherwise, we assume `e[0]` is a method of `args[0]`\n    let ret = { val: args[0].val[e[0]](...args.slice(1).map(argi => argi.val))\n              , prefEDO: args.map(argi => argi.prefEDO).reduce(cbnEDOs) };\n    // for some operations on intervals we don't want to look at every\n    //  argument's perferred EDO\n    if (e[0] == \"pow\") {\n      ret.prefEDO = args[0].prefEDO;\n    }\n    if (e[0] == \"red\" || e[0] == \"reb\") {\n      if (args[1] && args[1].equals && args[1].equals(2)) {\n        ret.prefEDO = args[0].prefEDO;\n      }\n      else {\n        ret.prefEDO = undefined;\n      }\n    }\n    return ret;\n  }\n  return { val: e, prefEDO: e == 2 ? 1 : undefined };\n}\n\nmodule['exports'].evalExpr = evalExpr;\n",
    "\nconst Fraction = require('fraction.js');\nconst Interval = require('../interval.js');\nconst {pyInterval, isPerfectDeg, baseNoteIntvToA} = require('../pythagorean.js');\nconst {fjsFactor} = require('../fjs.js');\nconst {edoPy, edoHasNeutrals, edoHasSemiNeutrals} = require('../edo.js');\n\nconst defaultRefNote = { intvToA4: Interval(1), hertz: Interval(440) };\n\nfunction perfPyInterval(d,o,reject) {\n  return isPerfectDeg(d) ? pyInterval(d,o) : reject;\n}\nfunction nonPerfPyInterval(d,o,reject) {\n  return isPerfectDeg(d) ? reject : pyInterval(d,o);\n}\nfunction augOrDimPyInterval(d,a,b,reject) {\n  const o = Fraction(a,b);\n  if (o.d != b) {\n    return reject;\n  }\n  const o_np = o.add(o.s,2);\n  return isPerfectDeg(d) ? pyInterval(d,o) : pyInterval(d,o_np);\n}\n\nfunction ensureNo2Or3(i,reject) {\n  return (i['2'] && i['2'] != 0) || (i['3'] && i['3'] != 0) ? reject : i;\n}\n\nfunction cbnEDOs(a,b) {\n  if (a && b) { return Fraction(1,a).gcd(1,b).d; }\n  else { return null; }\n}\n\nfunction baseNoteIntvToReference(x,referenceNoteIntvToA4) {\n  return baseNoteIntvToA(x).div(referenceNoteIntvToA4);\n}\n\nmodule['exports'].defaultRefNote = defaultRefNote;\nmodule['exports'].perfPyInterval = perfPyInterval;\nmodule['exports'].nonPerfPyInterval = nonPerfPyInterval;\nmodule['exports'].augOrDimPyInterval = augOrDimPyInterval;\nmodule['exports'].ensureNo2Or3 = ensureNo2Or3;\nmodule['exports'].cbnEDOs = cbnEDOs;\nmodule['exports'].baseNoteIntvToReference = baseNoteIntvToReference;\n",
    "// Generated automatically by nearley, version 2.19.8\n// http://github.com/Hardmath123/nearley\n(function () {\nfunction id(x) { return x[0]; }\n\n\nconst Fraction = require('fraction.js');\nconst Interval = require('../interval.js');\nconst {pyInterval, pyRedDeg, baseNoteIntvToA} = require('../pythagorean.js');\nconst {fjsFactor, fjsParams, nfjsParams} = require('../fjs.js');\nconst {edoPy} = require('../edo.js');\nconst helpers = require('./grammar-helpers.js');\nconst {evalExpr} = require('./eval.js');\n\nvar grammar = {\n    Lexer: undefined,\n    ParserRules: [\n    {\"name\": \"_$ebnf$1\", \"symbols\": []},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", \"wschar\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"__$ebnf$1\", \"symbols\": [\"wschar\"]},\n    {\"name\": \"__$ebnf$1\", \"symbols\": [\"__$ebnf$1\", \"wschar\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"__\", \"symbols\": [\"__$ebnf$1\"], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"wschar\", \"symbols\": [/[ \\t\\n\\v\\f]/], \"postprocess\": id},\n    {\"name\": \"top1\", \"symbols\": [\"_\", \"top2\", \"_\"], \"postprocess\":  function (d,_,reject) { let d1 = Object.assign({},d[1]); // copy this!\n        d1.refNote = helpers.defaultRefNote;\n        return d1; } },\n    {\"name\": \"top1$string$1\", \"symbols\": [{\"literal\":\"w\"}, {\"literal\":\"h\"}, {\"literal\":\"e\"}, {\"literal\":\"r\"}, {\"literal\":\"e\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"top1$ebnf$1\", \"symbols\": [\"hertz\"], \"postprocess\": id},\n    {\"name\": \"top1$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"top1\", \"symbols\": [\"_\", \"top2\", \"__\", \"top1$string$1\", \"__\", \"pyNote\", \"_\", {\"literal\":\"=\"}, \"_\", \"decimal\", \"top1$ebnf$1\", \"_\"], \"postprocess\":  function (d,_,reject) { let d1 = Object.assign({},d[1]); // copy this!\n        d1.refNote = {};\n        d1.refNote.intvToA4 = evalExpr(d[5], helpers.defaultRefNote).val;\n        d1.refNote.hertz    = Interval(d[9]);\n        return d1; } },\n    {\"name\": \"top1$string$2\", \"symbols\": [{\"literal\":\"w\"}, {\"literal\":\"h\"}, {\"literal\":\"e\"}, {\"literal\":\"r\"}, {\"literal\":\"e\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"top1\", \"symbols\": [\"_\", \"top2\", \"__\", \"top1$string$2\", \"__\", \"pyNote\", \"_\", {\"literal\":\"=\"}, \"_\", \"pyNote\", \"_\", {\"literal\":\"\\\\\"}, \"_\", \"posInt\", \"_\"], \"postprocess\":  function (d,_,reject) { let d1 = Object.assign({},d[1]); // copy this!\n        const d5 = evalExpr(d[5], helpers.defaultRefNote).val;\n        const d9 = evalExpr(d[9], helpers.defaultRefNote).val;\n        const d13 = parseInt(d[13]);\n        if (!d5 || !d5.equals(d9)) { return reject; }\n        d1.refNote = {};\n        d1.refNote.intvToA4 = d9;\n        d1.refNote.hertz    = Interval(2).pow(edoPy(d13,d9),d13).mul(440);\n        return d1; } },\n    {\"name\": \"top2\", \"symbols\": [\"intvSExpr1\"], \"postprocess\": d => ({type: [\"interval\", \"symbol\"], expr: d[0]})},\n    {\"name\": \"top2\", \"symbols\": [\"intvMExpr1\"], \"postprocess\": d => ({type: [\"interval\", \"multiplicative\"], expr: d[0]})},\n    {\"name\": \"top2\", \"symbols\": [\"intvAExpr1\"], \"postprocess\": d => ({type: [\"interval\", \"additive\"], expr: d[0]})},\n    {\"name\": \"top2\", \"symbols\": [\"noteSExpr1\"], \"postprocess\": d => ({type: [\"note\", \"symbol\"], expr: d[0]})},\n    {\"name\": \"top2\", \"symbols\": [\"noteMExpr1\"], \"postprocess\": d => ({type: [\"note\", \"multiplicative\"], expr: d[0]})},\n    {\"name\": \"top2\", \"symbols\": [\"noteAExpr1\"], \"postprocess\": d => ({type: [\"note\", \"additive\"], expr: d[0]})},\n    {\"name\": \"intvMExpr1\", \"symbols\": [\"intvMExpr1\", \"_\", {\"literal\":\"*\"}, \"_\", \"intvMExpr2\"], \"postprocess\": d => [\"mul\", d[0], d[4]]},\n    {\"name\": \"intvMExpr1\", \"symbols\": [\"intvMExpr1\", \"_\", {\"literal\":\"/\"}, \"_\", \"intvMExpr2\"], \"postprocess\": d => [\"div\", d[0], d[4]]},\n    {\"name\": \"intvMExpr1\", \"symbols\": [\"noteMExpr1\", \"_\", {\"literal\":\"/\"}, \"_\", \"noteMExpr2\"], \"postprocess\": d => [\"div\", d[0], d[4]]},\n    {\"name\": \"intvMExpr1\", \"symbols\": [\"intvMExpr2\"], \"postprocess\": id},\n    {\"name\": \"intvMExpr2\", \"symbols\": [\"intvMExpr3\", \"_\", {\"literal\":\"^\"}, \"_\", \"frcExpr3\"], \"postprocess\": d => [\"pow\", d[0], d[4]]},\n    {\"name\": \"intvMExpr2$string$1\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"q\"}, {\"literal\":\"r\"}, {\"literal\":\"t\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvMExpr2\", \"symbols\": [\"intvMExpr2$string$1\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"sqrt\", d[4]]},\n    {\"name\": \"intvMExpr2$string$2\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"d\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvMExpr2\", \"symbols\": [\"intvMExpr2$string$2\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"red\", d[4]]},\n    {\"name\": \"intvMExpr2$string$3\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"b\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvMExpr2\", \"symbols\": [\"intvMExpr2$string$3\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"reb\", d[4]]},\n    {\"name\": \"intvMExpr2$string$4\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"d\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvMExpr2\", \"symbols\": [\"intvMExpr2$string$4\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"red\", d[4], d[8]]},\n    {\"name\": \"intvMExpr2$string$5\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"b\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvMExpr2\", \"symbols\": [\"intvMExpr2$string$5\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"reb\", d[4], d[8]]},\n    {\"name\": \"intvMExpr2$string$6\", \"symbols\": [{\"literal\":\"m\"}, {\"literal\":\"e\"}, {\"literal\":\"d\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvMExpr2\", \"symbols\": [\"intvMExpr2$string$6\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"!med\", d[4], d[8]]},\n    {\"name\": \"intvMExpr2$string$7\", \"symbols\": [{\"literal\":\"a\"}, {\"literal\":\"p\"}, {\"literal\":\"p\"}, {\"literal\":\"r\"}, {\"literal\":\"o\"}, {\"literal\":\"x\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvMExpr2\", \"symbols\": [\"intvMExpr2$string$7\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"posInt\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"!edoApprox\", d[4], parseInt(d[8])]},\n    {\"name\": \"intvMExpr2\", \"symbols\": [\"intvSymbol\"], \"postprocess\": id},\n    {\"name\": \"intvMExpr2\", \"symbols\": [\"intvMExpr3\"], \"postprocess\": id},\n    {\"name\": \"intvMExpr3\", \"symbols\": [\"posInt\"], \"postprocess\": d => Interval(d[0])},\n    {\"name\": \"intvMExpr3\", \"symbols\": [\"int\", \"_\", {\"literal\":\"\\\\\"}, \"_\", \"posInt\"], \"postprocess\": d => [\"!inEDO\", parseInt(d[0]), parseInt(d[4])]},\n    {\"name\": \"intvMExpr3\", \"symbols\": [\"intvMEDOExpr3\", \"_\", {\"literal\":\"\\\\\"}, \"_\", \"posInt\"], \"postprocess\": d => [\"!inEDO\", d[0], parseInt(d[4])]},\n    {\"name\": \"intvMExpr3\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"noteMExpr1\", \"symbols\": [\"noteMExpr1\", \"_\", {\"literal\":\"*\"}, \"_\", \"intvMExpr2\"], \"postprocess\": d => [\"mul\", d[0], d[4]]},\n    {\"name\": \"noteMExpr1\", \"symbols\": [\"intvMExpr1\", \"_\", {\"literal\":\"*\"}, \"_\", \"noteMExpr2\"], \"postprocess\": d => [\"mul\", d[0], d[4]]},\n    {\"name\": \"noteMExpr1\", \"symbols\": [\"noteMExpr1\", \"_\", {\"literal\":\"/\"}, \"_\", \"intvMExpr2\"], \"postprocess\": d => [\"div\", d[0], d[4]]},\n    {\"name\": \"noteMExpr1\", \"symbols\": [\"noteMExpr2\"], \"postprocess\": id},\n    {\"name\": \"noteMExpr2$string$1\", \"symbols\": [{\"literal\":\"a\"}, {\"literal\":\"p\"}, {\"literal\":\"p\"}, {\"literal\":\"r\"}, {\"literal\":\"o\"}, {\"literal\":\"x\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"noteMExpr2\", \"symbols\": [\"noteMExpr2$string$1\", \"_\", {\"literal\":\"(\"}, \"_\", \"noteMExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"posInt\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"!edoApprox\", d[4], parseInt(d[8])]},\n    {\"name\": \"noteMExpr2\", \"symbols\": [\"noteSymbol\"], \"postprocess\": id},\n    {\"name\": \"noteMExpr2\", \"symbols\": [\"noteMEDOExpr2\", \"_\", {\"literal\":\"\\\\\"}, \"_\", \"posInt\"], \"postprocess\": d => [\"!inEDO\", d[0], parseInt(d[4])]},\n    {\"name\": \"noteMExpr2\", \"symbols\": [\"decimal\", \"hertz\"], \"postprocess\": d => [\"div\", Interval(d[0]), [\"!refHertz\"]]},\n    {\"name\": \"noteMExpr2\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"noteMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"intvAExpr1\", \"symbols\": [\"intvAExpr1\", \"_\", {\"literal\":\"+\"}, \"_\", \"intvAExpr2\"], \"postprocess\": d => [\"mul\", d[0], d[4]]},\n    {\"name\": \"intvAExpr1\", \"symbols\": [\"intvAExpr1\", \"_\", {\"literal\":\"-\"}, \"_\", \"intvAExpr2\"], \"postprocess\": d => [\"div\", d[0], d[4]]},\n    {\"name\": \"intvAExpr1\", \"symbols\": [\"noteAExpr1\", \"_\", {\"literal\":\"-\"}, \"_\", \"noteAExpr2\"], \"postprocess\": d => [\"div\", d[0], d[4]]},\n    {\"name\": \"intvAExpr1\", \"symbols\": [\"intvAExpr2\"], \"postprocess\": id},\n    {\"name\": \"intvAExpr2\", \"symbols\": [\"intvAExpr3\", \"_\", {\"literal\":\"x\"}, \"_\", \"frcExpr3\"], \"postprocess\": d => [\"pow\", d[0], d[4]]},\n    {\"name\": \"intvAExpr2\", \"symbols\": [\"frcExpr3\", \"_\", {\"literal\":\"x\"}, \"_\", \"intvAExpr3\"], \"postprocess\": d => [\"pow\", d[4], d[0]]},\n    {\"name\": \"intvAExpr2\", \"symbols\": [\"intvAExpr3\"], \"postprocess\": id},\n    {\"name\": \"intvAExpr3$string$1\", \"symbols\": [{\"literal\":\"c\"}, {\"literal\":\"e\"}, {\"literal\":\"n\"}, {\"literal\":\"t\"}, {\"literal\":\"s\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvAExpr3\", \"symbols\": [\"intvAExpr3$string$1\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[4]},\n    {\"name\": \"intvAExpr3$string$2\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"d\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvAExpr3\", \"symbols\": [\"intvAExpr3$string$2\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvAExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"red\", d[4]]},\n    {\"name\": \"intvAExpr3$string$3\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"b\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvAExpr3\", \"symbols\": [\"intvAExpr3$string$3\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvAExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"reb\", d[4]]},\n    {\"name\": \"intvAExpr3$string$4\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"d\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvAExpr3\", \"symbols\": [\"intvAExpr3$string$4\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvAExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"red\", d[4], d[8]]},\n    {\"name\": \"intvAExpr3$string$5\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"b\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvAExpr3\", \"symbols\": [\"intvAExpr3$string$5\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvAExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"reb\", d[4], d[8]]},\n    {\"name\": \"intvAExpr3$string$6\", \"symbols\": [{\"literal\":\"a\"}, {\"literal\":\"p\"}, {\"literal\":\"p\"}, {\"literal\":\"r\"}, {\"literal\":\"o\"}, {\"literal\":\"x\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvAExpr3\", \"symbols\": [\"intvAExpr3$string$6\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvAExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"posInt\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"!edoApprox\", d[4], parseInt(d[8])]},\n    {\"name\": \"intvAExpr3\", \"symbols\": [\"intvSymbol\"], \"postprocess\": id},\n    {\"name\": \"intvAExpr3\", \"symbols\": [\"intvAExpr4\"], \"postprocess\": id},\n    {\"name\": \"intvAExpr4\", \"symbols\": [\"decimal\", {\"literal\":\"c\"}], \"postprocess\": d => [\"!cents\", d[0]]},\n    {\"name\": \"intvAExpr4\", \"symbols\": [\"intvAEDOExpr3\", \"_\", {\"literal\":\"\\\\\"}, \"_\", \"posInt\"], \"postprocess\": d => [\"!inEDO\", d[0], parseInt(d[4])]},\n    {\"name\": \"intvAExpr4\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"intvAExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"noteAExpr1\", \"symbols\": [\"noteAExpr1\", \"_\", {\"literal\":\"+\"}, \"_\", \"intvAExpr2\"], \"postprocess\": d => [\"mul\", d[0], d[4]]},\n    {\"name\": \"noteAExpr1\", \"symbols\": [\"intvAExpr1\", \"_\", {\"literal\":\"+\"}, \"_\", \"noteAExpr2\"], \"postprocess\": d => [\"mul\", d[0], d[4]]},\n    {\"name\": \"noteAExpr1\", \"symbols\": [\"noteAExpr1\", \"_\", {\"literal\":\"-\"}, \"_\", \"intvAExpr2\"], \"postprocess\": d => [\"div\", d[0], d[4]]},\n    {\"name\": \"noteAExpr1\", \"symbols\": [\"noteAExpr2\"], \"postprocess\": id},\n    {\"name\": \"noteAExpr2$string$1\", \"symbols\": [{\"literal\":\"a\"}, {\"literal\":\"p\"}, {\"literal\":\"p\"}, {\"literal\":\"r\"}, {\"literal\":\"o\"}, {\"literal\":\"x\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"noteAExpr2\", \"symbols\": [\"noteAExpr2$string$1\", \"_\", {\"literal\":\"(\"}, \"_\", \"noteAExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"posInt\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"!edoApprox\", d[4], parseInt(d[8])]},\n    {\"name\": \"noteAExpr2\", \"symbols\": [\"noteSymbol\"], \"postprocess\": id},\n    {\"name\": \"noteAExpr2\", \"symbols\": [\"noteAEDOExpr2\", \"_\", {\"literal\":\"\\\\\"}, \"_\", \"posInt\"], \"postprocess\": d => [\"!inEDO\", d[0], parseInt(d[4])]},\n    {\"name\": \"noteAExpr2\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"noteAExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"intvMEDOExpr1\", \"symbols\": [\"intvMEDOExpr1\", \"_\", {\"literal\":\"*\"}, \"_\", \"intvMEDOExpr2\"], \"postprocess\": d => [\"+\", d[0], d[4]]},\n    {\"name\": \"intvMEDOExpr1\", \"symbols\": [\"intvMEDOExpr1\", \"_\", {\"literal\":\"/\"}, \"_\", \"intvMEDOExpr2\"], \"postprocess\": d => [\"-\", d[0], d[4]]},\n    {\"name\": \"intvMEDOExpr1\", \"symbols\": [\"noteMEDOExpr1\", \"_\", {\"literal\":\"/\"}, \"_\", \"noteMEDOExpr2\"], \"postprocess\": d => [\"-\", d[0], d[4]]},\n    {\"name\": \"intvMEDOExpr1\", \"symbols\": [\"intvMEDOExpr2\"], \"postprocess\": id},\n    {\"name\": \"intvMEDOExpr2\", \"symbols\": [\"intvMEDOExpr3\", \"_\", {\"literal\":\"^\"}, \"_\", \"intExpr1\"], \"postprocess\": d => [\"*\", d[0], d[4]]},\n    {\"name\": \"intvMEDOExpr2\", \"symbols\": [\"intvMEDOExpr3\"], \"postprocess\": id},\n    {\"name\": \"intvMEDOExpr3\", \"symbols\": [\"upsDnsIntv\"], \"postprocess\": id},\n    {\"name\": \"intvMEDOExpr3$string$1\", \"symbols\": [{\"literal\":\"T\"}, {\"literal\":\"T\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvMEDOExpr3\", \"symbols\": [\"intvMEDOExpr3$string$1\"], \"postprocess\": d => [\"!edoTT\"]},\n    {\"name\": \"intvMEDOExpr3\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"intvMEDOExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"noteMEDOExpr1\", \"symbols\": [\"noteMEDOExpr1\", \"_\", {\"literal\":\"*\"}, \"_\", \"intvMEDOExpr2\"], \"postprocess\": d => [\"+\", d[0], d[4]]},\n    {\"name\": \"noteMEDOExpr1\", \"symbols\": [\"intvMEDOExpr1\", \"_\", {\"literal\":\"*\"}, \"_\", \"noteMEDOExpr2\"], \"postprocess\": d => [\"+\", d[0], d[4]]},\n    {\"name\": \"noteMEDOExpr1\", \"symbols\": [\"noteMEDOExpr1\", \"_\", {\"literal\":\"/\"}, \"_\", \"intvMEDOExpr2\"], \"postprocess\": d => [\"-\", d[0], d[4]]},\n    {\"name\": \"noteMEDOExpr1\", \"symbols\": [\"noteMEDOExpr2\"], \"postprocess\": id},\n    {\"name\": \"noteMEDOExpr2\", \"symbols\": [\"upsDnsNote\"], \"postprocess\": id},\n    {\"name\": \"noteMEDOExpr2\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"noteMEDOExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"intvAEDOExpr1\", \"symbols\": [\"intvAEDOExpr1\", \"_\", {\"literal\":\"+\"}, \"_\", \"intvAEDOExpr2\"], \"postprocess\": d => [\"+\", d[0], d[4]]},\n    {\"name\": \"intvAEDOExpr1\", \"symbols\": [\"intvAEDOExpr1\", \"_\", {\"literal\":\"-\"}, \"_\", \"intvAEDOExpr2\"], \"postprocess\": d => [\"-\", d[0], d[4]]},\n    {\"name\": \"intvAEDOExpr1\", \"symbols\": [\"noteAEDOExpr1\", \"_\", {\"literal\":\"-\"}, \"_\", \"noteAEDOExpr2\"], \"postprocess\": d => [\"-\", d[0], d[4]]},\n    {\"name\": \"intvAEDOExpr1\", \"symbols\": [\"intvAEDOExpr2\"], \"postprocess\": id},\n    {\"name\": \"intvAEDOExpr2\", \"symbols\": [\"intvAEDOExpr3\", \"_\", {\"literal\":\"x\"}, \"_\", \"intExpr1\"], \"postprocess\": d => [\"*\", d[0], d[4]]},\n    {\"name\": \"intvAEDOExpr2\", \"symbols\": [\"intExpr1\", \"_\", {\"literal\":\"x\"}, \"_\", \"intvAEDOExpr3\"], \"postprocess\": d => [\"*\", d[0], d[4]]},\n    {\"name\": \"intvAEDOExpr2\", \"symbols\": [\"intvAEDOExpr3\"], \"postprocess\": id},\n    {\"name\": \"intvAEDOExpr3\", \"symbols\": [{\"literal\":\"-\"}, \"_\", \"intvAEDOExpr4\"], \"postprocess\": d => [\"-\", 0, d[2]]},\n    {\"name\": \"intvAEDOExpr3\", \"symbols\": [\"intvAEDOExpr4\"], \"postprocess\": id},\n    {\"name\": \"intvAEDOExpr4\", \"symbols\": [\"nonNegInt\"], \"postprocess\": d => parseInt(d[0])},\n    {\"name\": \"intvAEDOExpr4\", \"symbols\": [\"upsDnsIntv\"], \"postprocess\": id},\n    {\"name\": \"intvAEDOExpr4$string$1\", \"symbols\": [{\"literal\":\"T\"}, {\"literal\":\"T\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvAEDOExpr4\", \"symbols\": [\"intvAEDOExpr4$string$1\"], \"postprocess\": d => [\"!edoTT\"]},\n    {\"name\": \"intvAEDOExpr4\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"intvAEDOExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"noteAEDOExpr1\", \"symbols\": [\"noteAEDOExpr1\", \"_\", {\"literal\":\"+\"}, \"_\", \"intvAEDOExpr2\"], \"postprocess\": d => [\"+\", d[0], d[4]]},\n    {\"name\": \"noteAEDOExpr1\", \"symbols\": [\"intvAEDOExpr1\", \"_\", {\"literal\":\"+\"}, \"_\", \"noteAEDOExpr2\"], \"postprocess\": d => [\"+\", d[0], d[4]]},\n    {\"name\": \"noteAEDOExpr1\", \"symbols\": [\"noteAEDOExpr1\", \"_\", {\"literal\":\"-\"}, \"_\", \"intvAEDOExpr2\"], \"postprocess\": d => [\"-\", d[0], d[4]]},\n    {\"name\": \"noteAEDOExpr1\", \"symbols\": [\"noteAEDOExpr2\"], \"postprocess\": id},\n    {\"name\": \"noteAEDOExpr2\", \"symbols\": [\"upsDnsNote\"], \"postprocess\": id},\n    {\"name\": \"noteAEDOExpr2\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"noteAEDOExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"intvSExpr1$string$1\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"d\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvSExpr1\", \"symbols\": [\"intvSExpr1$string$1\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvSExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"red\", d[4]]},\n    {\"name\": \"intvSExpr1$string$2\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"b\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvSExpr1\", \"symbols\": [\"intvSExpr1$string$2\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvSExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"reb\", d[4]]},\n    {\"name\": \"intvSExpr1$string$3\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"d\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvSExpr1\", \"symbols\": [\"intvSExpr1$string$3\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvSExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"red\", d[4], d[8]]},\n    {\"name\": \"intvSExpr1$string$4\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"e\"}, {\"literal\":\"b\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvSExpr1\", \"symbols\": [\"intvSExpr1$string$4\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvSExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"intvMExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"reb\", d[4], d[8]]},\n    {\"name\": \"intvSExpr1$string$5\", \"symbols\": [{\"literal\":\"a\"}, {\"literal\":\"p\"}, {\"literal\":\"p\"}, {\"literal\":\"r\"}, {\"literal\":\"o\"}, {\"literal\":\"x\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvSExpr1\", \"symbols\": [\"intvSExpr1$string$5\", \"_\", {\"literal\":\"(\"}, \"_\", \"intvSExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"posInt\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"!edoApprox\", d[4], parseInt(d[8])]},\n    {\"name\": \"intvSExpr1\", \"symbols\": [\"intvSExpr2\"], \"postprocess\": id},\n    {\"name\": \"intvSExpr2\", \"symbols\": [\"intvSymbol\"], \"postprocess\": id},\n    {\"name\": \"intvSExpr2\", \"symbols\": [\"int\", \"_\", {\"literal\":\"\\\\\"}, \"_\", \"posInt\"], \"postprocess\": d => [\"!inEDO\", parseInt(d[0]), parseInt(d[4])]},\n    {\"name\": \"intvSExpr2\", \"symbols\": [\"upsDnsIntv\", \"_\", {\"literal\":\"\\\\\"}, \"_\", \"posInt\"], \"postprocess\": d => [\"!inEDO\", d[0], parseInt(d[4])]},\n    {\"name\": \"intvSExpr2$string$1\", \"symbols\": [{\"literal\":\"T\"}, {\"literal\":\"T\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvSExpr2\", \"symbols\": [\"intvSExpr2$string$1\", \"_\", {\"literal\":\"\\\\\"}, \"_\", \"posInt\"], \"postprocess\": d => [\"!inEDO\", [\"!edoTT\"], parseInt(d[4])]},\n    {\"name\": \"intvSExpr2\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"intvSExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"noteSExpr1$string$1\", \"symbols\": [{\"literal\":\"a\"}, {\"literal\":\"p\"}, {\"literal\":\"p\"}, {\"literal\":\"r\"}, {\"literal\":\"o\"}, {\"literal\":\"x\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"noteSExpr1\", \"symbols\": [\"noteSExpr1$string$1\", \"_\", {\"literal\":\"(\"}, \"_\", \"noteSExpr1\", \"_\", {\"literal\":\",\"}, \"_\", \"posInt\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => [\"!edoApprox\", d[4], parseInt(d[8])]},\n    {\"name\": \"noteSExpr1\", \"symbols\": [\"noteSymbol\"], \"postprocess\": id},\n    {\"name\": \"noteSExpr1\", \"symbols\": [\"upsDnsNote\", \"_\", {\"literal\":\"\\\\\"}, \"_\", \"posInt\"], \"postprocess\": d => [\"!inEDO\", d[0], parseInt(d[4])]},\n    {\"name\": \"noteSExpr1\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"noteSExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"intvSymbol\", \"symbols\": [\"fjsIntv\"], \"postprocess\": id},\n    {\"name\": \"intvSymbol\", \"symbols\": [\"nfjsNeutIntv\"], \"postprocess\": id},\n    {\"name\": \"intvSymbol$string$1\", \"symbols\": [{\"literal\":\"N\"}, {\"literal\":\"F\"}, {\"literal\":\"J\"}, {\"literal\":\"S\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvSymbol\", \"symbols\": [\"intvSymbol$string$1\", \"_\", {\"literal\":\"(\"}, \"_\", \"nfjsIntv\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[4]},\n    {\"name\": \"intvSymbol\", \"symbols\": [\"snpyIntv\"], \"postprocess\": id},\n    {\"name\": \"intvSymbol$string$2\", \"symbols\": [{\"literal\":\"T\"}, {\"literal\":\"T\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"intvSymbol\", \"symbols\": [\"intvSymbol$string$2\"], \"postprocess\": _ => Interval(2).sqrt()},\n    {\"name\": \"noteSymbol\", \"symbols\": [\"fjsNote\"], \"postprocess\": id},\n    {\"name\": \"noteSymbol\", \"symbols\": [\"nfjsNeutNote\"], \"postprocess\": id},\n    {\"name\": \"noteSymbol$string$1\", \"symbols\": [{\"literal\":\"N\"}, {\"literal\":\"F\"}, {\"literal\":\"J\"}, {\"literal\":\"S\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"noteSymbol\", \"symbols\": [\"noteSymbol$string$1\", \"_\", {\"literal\":\"(\"}, \"_\", \"nfjsNote\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[4]},\n    {\"name\": \"noteSymbol\", \"symbols\": [\"npyNote\"], \"postprocess\": id},\n    {\"name\": \"pyIntv\", \"symbols\": [{\"literal\":\"P\"}, \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.perfPyInterval(d[1],0,reject)},\n    {\"name\": \"pyIntv\", \"symbols\": [{\"literal\":\"M\"}, \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.nonPerfPyInterval(d[1],Fraction(1,2),reject)},\n    {\"name\": \"pyIntv\", \"symbols\": [{\"literal\":\"m\"}, \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.nonPerfPyInterval(d[1],Fraction(-1,2),reject)},\n    {\"name\": \"pyIntv$ebnf$1\", \"symbols\": [{\"literal\":\"A\"}]},\n    {\"name\": \"pyIntv$ebnf$1\", \"symbols\": [\"pyIntv$ebnf$1\", {\"literal\":\"A\"}], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"pyIntv\", \"symbols\": [\"pyIntv$ebnf$1\", \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.augOrDimPyInterval(d[1],d[0].length,1,reject)},\n    {\"name\": \"pyIntv$ebnf$2\", \"symbols\": [{\"literal\":\"d\"}]},\n    {\"name\": \"pyIntv$ebnf$2\", \"symbols\": [\"pyIntv$ebnf$2\", {\"literal\":\"d\"}], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"pyIntv\", \"symbols\": [\"pyIntv$ebnf$2\", \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.augOrDimPyInterval(d[1],-d[0].length,1,reject)},\n    {\"name\": \"pyIntv\", \"symbols\": [\"posInt\", {\"literal\":\"A\"}, \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.augOrDimPyInterval(d[2],d[0],1,reject)},\n    {\"name\": \"pyIntv\", \"symbols\": [\"posInt\", {\"literal\":\"d\"}, \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.augOrDimPyInterval(d[2],d[0],1,reject)},\n    {\"name\": \"npyIntv$subexpression$1\", \"symbols\": [/[nN]/], \"postprocess\": function(d) {return d.join(\"\"); }},\n    {\"name\": \"npyIntv\", \"symbols\": [\"npyIntv$subexpression$1\", \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.nonPerfPyInterval(d[1],0,reject)},\n    {\"name\": \"npyIntv$string$1\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"A\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"npyIntv\", \"symbols\": [\"npyIntv$string$1\", \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.augOrDimPyInterval(d[1],1,2,reject)},\n    {\"name\": \"npyIntv$string$2\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"d\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"npyIntv\", \"symbols\": [\"npyIntv$string$2\", \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.augOrDimPyInterval(d[1],-1,2,reject)},\n    {\"name\": \"npyIntv$string$3\", \"symbols\": [{\"literal\":\"/\"}, {\"literal\":\"2\"}, {\"literal\":\"-\"}, {\"literal\":\"A\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"npyIntv\", \"symbols\": [\"posInt\", \"npyIntv$string$3\", \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.augOrDimPyInterval(d[2],d[0],2,reject)},\n    {\"name\": \"npyIntv$string$4\", \"symbols\": [{\"literal\":\"/\"}, {\"literal\":\"2\"}, {\"literal\":\"-\"}, {\"literal\":\"d\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"npyIntv\", \"symbols\": [\"posInt\", \"npyIntv$string$4\", \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.augOrDimPyInterval(d[2],d[0],2,reject)},\n    {\"name\": \"snpyIntv$string$1\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"M\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"snpyIntv\", \"symbols\": [\"snpyIntv$string$1\", \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.nonPerfPyInterval(d[1],Fraction(1,4),reject)},\n    {\"name\": \"snpyIntv$string$2\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"m\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"snpyIntv\", \"symbols\": [\"snpyIntv$string$2\", \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.nonPerfPyInterval(d[1],Fraction(-1,4),reject)},\n    {\"name\": \"snpyIntv$string$3\", \"symbols\": [{\"literal\":\"/\"}, {\"literal\":\"4\"}, {\"literal\":\"-\"}, {\"literal\":\"A\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"snpyIntv\", \"symbols\": [\"posInt\", \"snpyIntv$string$3\", \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.augOrDimPyInterval(d[2],d[0],4,reject)},\n    {\"name\": \"snpyIntv$string$4\", \"symbols\": [{\"literal\":\"/\"}, {\"literal\":\"4\"}, {\"literal\":\"-\"}, {\"literal\":\"d\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"snpyIntv\", \"symbols\": [\"posInt\", \"snpyIntv$string$4\", \"pyDeg\"], \"postprocess\": (d,_,reject) => helpers.augOrDimPyInterval(d[2],d[0],4,reject)},\n    {\"name\": \"pyDeg\", \"symbols\": [\"posInt\"], \"postprocess\": d => parseInt(d[0])},\n    {\"name\": \"pyDeg\", \"symbols\": [{\"literal\":\"-\"}, \"posInt\"], \"postprocess\": d => - parseInt(d[1])},\n    {\"name\": \"pyNote\", \"symbols\": [{\"literal\":\"A\"}], \"postprocess\": _ => [\"recip\", [\"!refIntvToA4\"]]},\n    {\"name\": \"pyNote$macrocall$2\", \"symbols\": [/[B-G]/]},\n    {\"name\": \"pyNote$macrocall$3\", \"symbols\": [\"pyNoteNoAccs\"]},\n    {\"name\": \"pyNote$macrocall$1$ebnf$1\", \"symbols\": [\"int\"], \"postprocess\": id},\n    {\"name\": \"pyNote$macrocall$1$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"pyNote$macrocall$1\", \"symbols\": [\"pyNote$macrocall$2\", \"pyNote$macrocall$3\", \"pyNote$macrocall$1$ebnf$1\"], \"postprocess\":  function(d) {\n        const d2 = d[2] ? parseInt(d[2]) : 4;\n        return [\"mul\", [\"div\", baseNoteIntvToA(d[0][0]), [\"!refIntvToA4\"]]\n                     , d[1][0].mul(Interval(2).pow(d2 - 4))]; } },\n    {\"name\": \"pyNote\", \"symbols\": [\"pyNote$macrocall$1\"], \"postprocess\": id},\n    {\"name\": \"pyNote$macrocall$5\", \"symbols\": [/[A-G]/]},\n    {\"name\": \"pyNote$macrocall$6\", \"symbols\": [\"pyNoteAccs\"]},\n    {\"name\": \"pyNote$macrocall$4$ebnf$1\", \"symbols\": [\"int\"], \"postprocess\": id},\n    {\"name\": \"pyNote$macrocall$4$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"pyNote$macrocall$4\", \"symbols\": [\"pyNote$macrocall$5\", \"pyNote$macrocall$6\", \"pyNote$macrocall$4$ebnf$1\"], \"postprocess\":  function(d) {\n        const d2 = d[2] ? parseInt(d[2]) : 4;\n        return [\"mul\", [\"div\", baseNoteIntvToA(d[0][0]), [\"!refIntvToA4\"]]\n                     , d[1][0].mul(Interval(2).pow(d2 - 4))]; } },\n    {\"name\": \"pyNote\", \"symbols\": [\"pyNote$macrocall$4\"], \"postprocess\": id},\n    {\"name\": \"pyNoteNoAccs\", \"symbols\": [], \"postprocess\": _ => Interval(1)},\n    {\"name\": \"pyNoteAccs$subexpression$1\", \"symbols\": [{\"literal\":\"\"}]},\n    {\"name\": \"pyNoteAccs$subexpression$1$string$1\", \"symbols\": [{\"literal\":\"n\"}, {\"literal\":\"a\"}, {\"literal\":\"t\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"pyNoteAccs$subexpression$1\", \"symbols\": [\"pyNoteAccs$subexpression$1$string$1\"]},\n    {\"name\": \"pyNoteAccs\", \"symbols\": [\"pyNoteAccs$subexpression$1\"], \"postprocess\": _ => Interval(1)},\n    {\"name\": \"pyNoteAccs$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"#\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$1\", \"symbols\": [\"pyNoteAccs$ebnf$1$subexpression$1\"]},\n    {\"name\": \"pyNoteAccs$ebnf$1$subexpression$2\", \"symbols\": [{\"literal\":\"\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$1$subexpression$2\", \"symbols\": [{\"literal\":\"#\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$1\", \"symbols\": [\"pyNoteAccs$ebnf$1\", \"pyNoteAccs$ebnf$1$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"pyNoteAccs\", \"symbols\": [\"pyNoteAccs$ebnf$1\"], \"postprocess\": d => pyInterval(1, d[0].length)},\n    {\"name\": \"pyNoteAccs$ebnf$2$subexpression$1$string$1\", \"symbols\": [{\"literal\":\"\\ud834\"}, {\"literal\":\"\\udd2a\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"pyNoteAccs$ebnf$2$subexpression$1\", \"symbols\": [\"pyNoteAccs$ebnf$2$subexpression$1$string$1\"]},\n    {\"name\": \"pyNoteAccs$ebnf$2$subexpression$1\", \"symbols\": [{\"literal\":\"X\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$2\", \"symbols\": [\"pyNoteAccs$ebnf$2$subexpression$1\"]},\n    {\"name\": \"pyNoteAccs$ebnf$2$subexpression$2$string$1\", \"symbols\": [{\"literal\":\"\\ud834\"}, {\"literal\":\"\\udd2a\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"pyNoteAccs$ebnf$2$subexpression$2\", \"symbols\": [\"pyNoteAccs$ebnf$2$subexpression$2$string$1\"]},\n    {\"name\": \"pyNoteAccs$ebnf$2$subexpression$2\", \"symbols\": [{\"literal\":\"X\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$2\", \"symbols\": [\"pyNoteAccs$ebnf$2\", \"pyNoteAccs$ebnf$2$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"pyNoteAccs$ebnf$3\", \"symbols\": []},\n    {\"name\": \"pyNoteAccs$ebnf$3$subexpression$1\", \"symbols\": [{\"literal\":\"\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$3$subexpression$1\", \"symbols\": [{\"literal\":\"#\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$3\", \"symbols\": [\"pyNoteAccs$ebnf$3\", \"pyNoteAccs$ebnf$3$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"pyNoteAccs\", \"symbols\": [\"pyNoteAccs$ebnf$2\", \"pyNoteAccs$ebnf$3\"], \"postprocess\": d => pyInterval(1, 2*d[0].length + d[1].length)},\n    {\"name\": \"pyNoteAccs$ebnf$4$subexpression$1\", \"symbols\": [{\"literal\":\"\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$4$subexpression$1\", \"symbols\": [{\"literal\":\"b\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$4\", \"symbols\": [\"pyNoteAccs$ebnf$4$subexpression$1\"]},\n    {\"name\": \"pyNoteAccs$ebnf$4$subexpression$2\", \"symbols\": [{\"literal\":\"\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$4$subexpression$2\", \"symbols\": [{\"literal\":\"b\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$4\", \"symbols\": [\"pyNoteAccs$ebnf$4\", \"pyNoteAccs$ebnf$4$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"pyNoteAccs\", \"symbols\": [\"pyNoteAccs$ebnf$4\"], \"postprocess\": d => pyInterval(-1, d[0].length)},\n    {\"name\": \"pyNoteAccs$ebnf$5\", \"symbols\": []},\n    {\"name\": \"pyNoteAccs$ebnf$5$subexpression$1\", \"symbols\": [{\"literal\":\"\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$5$subexpression$1\", \"symbols\": [{\"literal\":\"b\"}]},\n    {\"name\": \"pyNoteAccs$ebnf$5\", \"symbols\": [\"pyNoteAccs$ebnf$5\", \"pyNoteAccs$ebnf$5$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"pyNoteAccs$ebnf$6$string$1\", \"symbols\": [{\"literal\":\"\\ud834\"}, {\"literal\":\"\\udd2b\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"pyNoteAccs$ebnf$6\", \"symbols\": [\"pyNoteAccs$ebnf$6$string$1\"]},\n    {\"name\": \"pyNoteAccs$ebnf$6$string$2\", \"symbols\": [{\"literal\":\"\\ud834\"}, {\"literal\":\"\\udd2b\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"pyNoteAccs$ebnf$6\", \"symbols\": [\"pyNoteAccs$ebnf$6\", \"pyNoteAccs$ebnf$6$string$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"pyNoteAccs\", \"symbols\": [\"pyNoteAccs$ebnf$5\", \"pyNoteAccs$ebnf$6\"], \"postprocess\": d => pyInterval(-1, 2*d[0].length + d[1].length)},\n    {\"name\": \"npyNote$macrocall$2\", \"symbols\": [/[A-G]/]},\n    {\"name\": \"npyNote$macrocall$3\", \"symbols\": [\"npyNoteAccs\"]},\n    {\"name\": \"npyNote$macrocall$1$ebnf$1\", \"symbols\": [\"int\"], \"postprocess\": id},\n    {\"name\": \"npyNote$macrocall$1$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"npyNote$macrocall$1\", \"symbols\": [\"npyNote$macrocall$2\", \"npyNote$macrocall$3\", \"npyNote$macrocall$1$ebnf$1\"], \"postprocess\":  function(d) {\n        const d2 = d[2] ? parseInt(d[2]) : 4;\n        return [\"mul\", [\"div\", baseNoteIntvToA(d[0][0]), [\"!refIntvToA4\"]]\n                     , d[1][0].mul(Interval(2).pow(d2 - 4))]; } },\n    {\"name\": \"npyNote\", \"symbols\": [\"npyNote$macrocall$1\"], \"postprocess\": id},\n    {\"name\": \"npyNoteAccs$ebnf$1\", \"symbols\": []},\n    {\"name\": \"npyNoteAccs$ebnf$1$subexpression$1$string$1\", \"symbols\": [{\"literal\":\"\\ud834\"}, {\"literal\":\"\\udd2a\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"npyNoteAccs$ebnf$1$subexpression$1\", \"symbols\": [\"npyNoteAccs$ebnf$1$subexpression$1$string$1\"]},\n    {\"name\": \"npyNoteAccs$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"X\"}]},\n    {\"name\": \"npyNoteAccs$ebnf$1\", \"symbols\": [\"npyNoteAccs$ebnf$1\", \"npyNoteAccs$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"npyNoteAccs$ebnf$2\", \"symbols\": []},\n    {\"name\": \"npyNoteAccs$ebnf$2$subexpression$1\", \"symbols\": [{\"literal\":\"\"}]},\n    {\"name\": \"npyNoteAccs$ebnf$2$subexpression$1\", \"symbols\": [{\"literal\":\"#\"}]},\n    {\"name\": \"npyNoteAccs$ebnf$2\", \"symbols\": [\"npyNoteAccs$ebnf$2\", \"npyNoteAccs$ebnf$2$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"npyNoteAccs$ebnf$3$subexpression$1$string$1\", \"symbols\": [{\"literal\":\"\\ud834\"}, {\"literal\":\"\\udd32\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"npyNoteAccs$ebnf$3$subexpression$1\", \"symbols\": [\"npyNoteAccs$ebnf$3$subexpression$1$string$1\"]},\n    {\"name\": \"npyNoteAccs$ebnf$3$subexpression$1\", \"symbols\": [{\"literal\":\"t\"}]},\n    {\"name\": \"npyNoteAccs$ebnf$3\", \"symbols\": [\"npyNoteAccs$ebnf$3$subexpression$1\"]},\n    {\"name\": \"npyNoteAccs$ebnf$3$subexpression$2$string$1\", \"symbols\": [{\"literal\":\"\\ud834\"}, {\"literal\":\"\\udd32\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"npyNoteAccs$ebnf$3$subexpression$2\", \"symbols\": [\"npyNoteAccs$ebnf$3$subexpression$2$string$1\"]},\n    {\"name\": \"npyNoteAccs$ebnf$3$subexpression$2\", \"symbols\": [{\"literal\":\"t\"}]},\n    {\"name\": \"npyNoteAccs$ebnf$3\", \"symbols\": [\"npyNoteAccs$ebnf$3\", \"npyNoteAccs$ebnf$3$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"npyNoteAccs\", \"symbols\": [\"npyNoteAccs$ebnf$1\", \"npyNoteAccs$ebnf$2\", \"npyNoteAccs$ebnf$3\"], \"postprocess\": d => pyInterval(1, 2*d[0].length + d[1].length + 0.5*d[2].length)},\n    {\"name\": \"npyNoteAccs$ebnf$4$subexpression$1$string$1\", \"symbols\": [{\"literal\":\"\\ud834\"}, {\"literal\":\"\\udd33\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"npyNoteAccs$ebnf$4$subexpression$1\", \"symbols\": [\"npyNoteAccs$ebnf$4$subexpression$1$string$1\"]},\n    {\"name\": \"npyNoteAccs$ebnf$4$subexpression$1\", \"symbols\": [{\"literal\":\"d\"}]},\n    {\"name\": \"npyNoteAccs$ebnf$4\", \"symbols\": [\"npyNoteAccs$ebnf$4$subexpression$1\"]},\n    {\"name\": \"npyNoteAccs$ebnf$4$subexpression$2$string$1\", \"symbols\": [{\"literal\":\"\\ud834\"}, {\"literal\":\"\\udd33\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"npyNoteAccs$ebnf$4$subexpression$2\", \"symbols\": [\"npyNoteAccs$ebnf$4$subexpression$2$string$1\"]},\n    {\"name\": \"npyNoteAccs$ebnf$4$subexpression$2\", \"symbols\": [{\"literal\":\"d\"}]},\n    {\"name\": \"npyNoteAccs$ebnf$4\", \"symbols\": [\"npyNoteAccs$ebnf$4\", \"npyNoteAccs$ebnf$4$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"npyNoteAccs$ebnf$5\", \"symbols\": []},\n    {\"name\": \"npyNoteAccs$ebnf$5$subexpression$1\", \"symbols\": [{\"literal\":\"\"}]},\n    {\"name\": \"npyNoteAccs$ebnf$5$subexpression$1\", \"symbols\": [{\"literal\":\"b\"}]},\n    {\"name\": \"npyNoteAccs$ebnf$5\", \"symbols\": [\"npyNoteAccs$ebnf$5\", \"npyNoteAccs$ebnf$5$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"npyNoteAccs$ebnf$6\", \"symbols\": []},\n    {\"name\": \"npyNoteAccs$ebnf$6$string$1\", \"symbols\": [{\"literal\":\"\\ud834\"}, {\"literal\":\"\\udd2b\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"npyNoteAccs$ebnf$6\", \"symbols\": [\"npyNoteAccs$ebnf$6\", \"npyNoteAccs$ebnf$6$string$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"npyNoteAccs\", \"symbols\": [\"npyNoteAccs$ebnf$4\", \"npyNoteAccs$ebnf$5\", \"npyNoteAccs$ebnf$6\"], \"postprocess\": d => pyInterval(-1, 2*d[0].length + d[1].length + 0.5*d[2].length)},\n    {\"name\": \"fjsIntv$macrocall$2\", \"symbols\": [\"pyIntv\"]},\n    {\"name\": \"fjsIntv$macrocall$3\", \"symbols\": [\"fjsIntv\"]},\n    {\"name\": \"fjsIntv$macrocall$1\", \"symbols\": [\"fjsIntv$macrocall$2\"], \"postprocess\": d => _ => d[0][0]},\n    {\"name\": \"fjsIntv$macrocall$1\", \"symbols\": [\"fjsIntv$macrocall$3\", {\"literal\":\"^\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"mul\", d[0][0], d[2](params)]},\n    {\"name\": \"fjsIntv$macrocall$1\", \"symbols\": [\"fjsIntv$macrocall$3\", {\"literal\":\"_\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"div\", d[0][0], d[2](params)]},\n    {\"name\": \"fjsIntv\", \"symbols\": [\"fjsIntv$macrocall$1\"], \"postprocess\": d => d[0](fjsParams)},\n    {\"name\": \"fjsNote$macrocall$2\", \"symbols\": [\"pyNote\"]},\n    {\"name\": \"fjsNote$macrocall$3\", \"symbols\": [\"fjsNote\"]},\n    {\"name\": \"fjsNote$macrocall$1\", \"symbols\": [\"fjsNote$macrocall$2\"], \"postprocess\": d => _ => d[0][0]},\n    {\"name\": \"fjsNote$macrocall$1\", \"symbols\": [\"fjsNote$macrocall$3\", {\"literal\":\"^\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"mul\", d[0][0], d[2](params)]},\n    {\"name\": \"fjsNote$macrocall$1\", \"symbols\": [\"fjsNote$macrocall$3\", {\"literal\":\"_\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"div\", d[0][0], d[2](params)]},\n    {\"name\": \"fjsNote\", \"symbols\": [\"fjsNote$macrocall$1\"], \"postprocess\": d => d[0](fjsParams)},\n    {\"name\": \"nfjsIntv\", \"symbols\": [\"nfjsNeutIntv\"], \"postprocess\": id},\n    {\"name\": \"nfjsIntv\", \"symbols\": [\"nfjsNonNeutIntv\"], \"postprocess\": id},\n    {\"name\": \"nfjsNote\", \"symbols\": [\"nfjsNeutNote\"], \"postprocess\": id},\n    {\"name\": \"nfjsNote\", \"symbols\": [\"nfjsNonNeutNote\"], \"postprocess\": id},\n    {\"name\": \"nfjsNeutIntv$macrocall$2\", \"symbols\": [\"npyIntv\"]},\n    {\"name\": \"nfjsNeutIntv$macrocall$3\", \"symbols\": [\"nfjsNeutIntv\"]},\n    {\"name\": \"nfjsNeutIntv$macrocall$1\", \"symbols\": [\"nfjsNeutIntv$macrocall$2\"], \"postprocess\": d => _ => d[0][0]},\n    {\"name\": \"nfjsNeutIntv$macrocall$1\", \"symbols\": [\"nfjsNeutIntv$macrocall$3\", {\"literal\":\"^\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"mul\", d[0][0], d[2](params)]},\n    {\"name\": \"nfjsNeutIntv$macrocall$1\", \"symbols\": [\"nfjsNeutIntv$macrocall$3\", {\"literal\":\"_\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"div\", d[0][0], d[2](params)]},\n    {\"name\": \"nfjsNeutIntv\", \"symbols\": [\"nfjsNeutIntv$macrocall$1\"], \"postprocess\": d => d[0](nfjsParams)},\n    {\"name\": \"nfjsNonNeutIntv$macrocall$2\", \"symbols\": [\"pyIntv\"]},\n    {\"name\": \"nfjsNonNeutIntv$macrocall$3\", \"symbols\": [\"nfjsNonNeutIntv\"]},\n    {\"name\": \"nfjsNonNeutIntv$macrocall$1\", \"symbols\": [\"nfjsNonNeutIntv$macrocall$2\"], \"postprocess\": d => _ => d[0][0]},\n    {\"name\": \"nfjsNonNeutIntv$macrocall$1\", \"symbols\": [\"nfjsNonNeutIntv$macrocall$3\", {\"literal\":\"^\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"mul\", d[0][0], d[2](params)]},\n    {\"name\": \"nfjsNonNeutIntv$macrocall$1\", \"symbols\": [\"nfjsNonNeutIntv$macrocall$3\", {\"literal\":\"_\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"div\", d[0][0], d[2](params)]},\n    {\"name\": \"nfjsNonNeutIntv\", \"symbols\": [\"nfjsNonNeutIntv$macrocall$1\"], \"postprocess\": d => d[0](nfjsParams)},\n    {\"name\": \"nfjsNeutNote$macrocall$2\", \"symbols\": [\"npyNote\"]},\n    {\"name\": \"nfjsNeutNote$macrocall$3\", \"symbols\": [\"nfjsNeutNote\"]},\n    {\"name\": \"nfjsNeutNote$macrocall$1\", \"symbols\": [\"nfjsNeutNote$macrocall$2\"], \"postprocess\": d => _ => d[0][0]},\n    {\"name\": \"nfjsNeutNote$macrocall$1\", \"symbols\": [\"nfjsNeutNote$macrocall$3\", {\"literal\":\"^\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"mul\", d[0][0], d[2](params)]},\n    {\"name\": \"nfjsNeutNote$macrocall$1\", \"symbols\": [\"nfjsNeutNote$macrocall$3\", {\"literal\":\"_\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"div\", d[0][0], d[2](params)]},\n    {\"name\": \"nfjsNeutNote\", \"symbols\": [\"nfjsNeutNote$macrocall$1\"], \"postprocess\": d => d[0](nfjsParams)},\n    {\"name\": \"nfjsNonNeutNote$macrocall$2\", \"symbols\": [\"pyNote\"]},\n    {\"name\": \"nfjsNonNeutNote$macrocall$3\", \"symbols\": [\"nfjsNonNeutNote\"]},\n    {\"name\": \"nfjsNonNeutNote$macrocall$1\", \"symbols\": [\"nfjsNonNeutNote$macrocall$2\"], \"postprocess\": d => _ => d[0][0]},\n    {\"name\": \"nfjsNonNeutNote$macrocall$1\", \"symbols\": [\"nfjsNonNeutNote$macrocall$3\", {\"literal\":\"^\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"mul\", d[0][0], d[2](params)]},\n    {\"name\": \"nfjsNonNeutNote$macrocall$1\", \"symbols\": [\"nfjsNonNeutNote$macrocall$3\", {\"literal\":\"_\"}, \"fjsAccs\"], \"postprocess\": d => params => [\"div\", d[0][0], d[2](params)]},\n    {\"name\": \"nfjsNonNeutNote\", \"symbols\": [\"nfjsNonNeutNote$macrocall$1\"], \"postprocess\": d => d[0](nfjsParams)},\n    {\"name\": \"fjsAccs\", \"symbols\": [\"fjsAcc\"], \"postprocess\": d => params => fjsFactor(d[0], params)},\n    {\"name\": \"fjsAccs\", \"symbols\": [\"fjsAccs\", {\"literal\":\",\"}, \"fjsAcc\"], \"postprocess\": d => params => d[0](params).mul(fjsFactor(d[2], params))},\n    {\"name\": \"fjsAcc\", \"symbols\": [\"posInt\"], \"postprocess\": (d,_,reject) => helpers.ensureNo2Or3(Interval(d[0]),reject)},\n    {\"name\": \"fjsAcc$string$1\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"q\"}, {\"literal\":\"r\"}, {\"literal\":\"t\"}, {\"literal\":\"(\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"fjsAcc\", \"symbols\": [\"fjsAcc$string$1\", \"fjsAcc\", {\"literal\":\")\"}], \"postprocess\": d => d[1].sqrt()},\n    {\"name\": \"fjsAcc$string$2\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"o\"}, {\"literal\":\"o\"}, {\"literal\":\"t\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"fjsAcc\", \"symbols\": [\"fjsAcc$string$2\", \"posInt\", {\"literal\":\"(\"}, \"fjsAcc\", {\"literal\":\")\"}], \"postprocess\": d => d[3].root(d[1])},\n    {\"name\": \"fjsAcc\", \"symbols\": [{\"literal\":\"(\"}, \"fjsAcc\", {\"literal\":\"^\"}, \"frcExpr3\", {\"literal\":\")\"}], \"postprocess\": d => d[1].pow(d[3])},\n    {\"name\": \"upsDnsIntv\", \"symbols\": [\"upsDns\", \"pyIntv\"], \"postprocess\": d => [\"+\", d[0], [\"!edoPy\", d[1]]]},\n    {\"name\": \"upsDnsIntv\", \"symbols\": [\"upsDns\", \"npyIntv\"], \"postprocess\": d => [\"+\", d[0], [\"!edoPy\", d[1]]]},\n    {\"name\": \"upsDnsIntv\", \"symbols\": [\"upsDns\", \"snpyIntv\"], \"postprocess\": d => [\"+\", d[0], [\"!edoPy\", d[1]]]},\n    {\"name\": \"upsDnsIntv\", \"symbols\": [\"upsDns\", \"posInt\"], \"postprocess\":  (d,_,reject) => (pyRedDeg(d[1]) == 4 || pyRedDeg(d[1]) == 5) && d[0] != 0\n        ? [\"+\", d[0], [\"!edoPy\", parseIng(d[1])]] : reject },\n    {\"name\": \"upsDnsIntv\", \"symbols\": [\"upsDns\", {\"literal\":\"~\"}, \"posInt\"], \"postprocess\":  (d,_,reject) => pyRedDeg(d[2]) == 1 ? reject :\n        pyRedDeg(d[2]) == 4 ? [\"+\", d[0], [\"!edoPy\", pyInterval(d[2],1,2)]] :\n        pyRedDeg(d[2]) == 5 ? [\"+\", d[0], [\"!edoPy\", pyInterval(d[2],-1,2)]] :\n                            [\"+\", d[0], [\"!edoPy\", pyInterval(d[2],0)]] },\n    {\"name\": \"upsDnsNote\", \"symbols\": [\"upsDns\", \"pyNote\"], \"postprocess\": d => [\"+\", d[0], [\"!edoPy\", d[1]]]},\n    {\"name\": \"upsDnsNote\", \"symbols\": [\"upsDns\", \"npyNote\"], \"postprocess\": d => [\"+\", d[0], [\"!edoPy\", d[1]]]},\n    {\"name\": \"upsDns\", \"symbols\": [], \"postprocess\": d => 0},\n    {\"name\": \"upsDns$ebnf$1\", \"symbols\": [{\"literal\":\"^\"}]},\n    {\"name\": \"upsDns$ebnf$1\", \"symbols\": [\"upsDns$ebnf$1\", {\"literal\":\"^\"}], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"upsDns\", \"symbols\": [\"upsDns$ebnf$1\"], \"postprocess\": d => d[0].length},\n    {\"name\": \"upsDns$ebnf$2\", \"symbols\": [{\"literal\":\"v\"}]},\n    {\"name\": \"upsDns$ebnf$2\", \"symbols\": [\"upsDns$ebnf$2\", {\"literal\":\"v\"}], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"upsDns\", \"symbols\": [\"upsDns$ebnf$2\"], \"postprocess\": d => - d[0].length},\n    {\"name\": \"frcExpr1\", \"symbols\": [\"frcExpr1\", \"_\", {\"literal\":\"+\"}, \"_\", \"frcExpr2\"], \"postprocess\": d => d[0].add(d[4])},\n    {\"name\": \"frcExpr1\", \"symbols\": [\"frcExpr1\", \"_\", {\"literal\":\"-\"}, \"_\", \"frcExpr2\"], \"postprocess\": d => d[0].sub(d[4])},\n    {\"name\": \"frcExpr1\", \"symbols\": [\"frcExpr2\"], \"postprocess\": id},\n    {\"name\": \"frcExpr2\", \"symbols\": [\"frcExpr2\", \"_\", {\"literal\":\"*\"}, \"_\", \"frcExpr3\"], \"postprocess\": d => d[0].mul(d[4])},\n    {\"name\": \"frcExpr2\", \"symbols\": [\"frcExpr2\", \"_\", {\"literal\":\"/\"}, \"_\", \"frcExpr3\"], \"postprocess\": d => d[0].div(d[4])},\n    {\"name\": \"frcExpr2\", \"symbols\": [\"frcExpr3\"], \"postprocess\": id},\n    {\"name\": \"frcExpr3\", \"symbols\": [{\"literal\":\"-\"}, \"_\", \"frcExpr4\"], \"postprocess\": d => d[2].neg()},\n    {\"name\": \"frcExpr3\", \"symbols\": [\"frcExpr4\"], \"postprocess\": id},\n    {\"name\": \"frcExpr4\", \"symbols\": [\"frcExpr5\", \"_\", {\"literal\":\"^\"}, \"_\", \"intExpr3\"], \"postprocess\": d => d[0].pow(d[4])},\n    {\"name\": \"frcExpr4\", \"symbols\": [\"frcExpr5\"], \"postprocess\": id},\n    {\"name\": \"frcExpr5\", \"symbols\": [\"nonNegInt\"], \"postprocess\": d => Fraction(d[0])},\n    {\"name\": \"frcExpr5\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"frcExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"intExpr1\", \"symbols\": [\"intExpr1\", \"_\", {\"literal\":\"+\"}, \"_\", \"intExpr2\"], \"postprocess\": d => d[0] + d[4]},\n    {\"name\": \"intExpr1\", \"symbols\": [\"intExpr1\", \"_\", {\"literal\":\"-\"}, \"_\", \"intExpr2\"], \"postprocess\": d => d[0] - d[4]},\n    {\"name\": \"intExpr1\", \"symbols\": [\"intExpr2\"], \"postprocess\": id},\n    {\"name\": \"intExpr2\", \"symbols\": [\"intExpr2\", \"_\", {\"literal\":\"*\"}, \"_\", \"intExpr3\"], \"postprocess\": d => d[0] * d[4]},\n    {\"name\": \"intExpr2\", \"symbols\": [\"intExpr3\"], \"postprocess\": id},\n    {\"name\": \"intExpr3\", \"symbols\": [{\"literal\":\"-\"}, \"_\", \"intExpr4\"], \"postprocess\": d => - d[2]},\n    {\"name\": \"intExpr3\", \"symbols\": [\"intExpr4\"], \"postprocess\": id},\n    {\"name\": \"intExpr4\", \"symbols\": [\"intExpr5\", \"_\", {\"literal\":\"^\"}, \"_\", \"posInt\"], \"postprocess\": d => Math.pow(d[0],d[4])},\n    {\"name\": \"intExpr4\", \"symbols\": [\"intExpr5\"], \"postprocess\": id},\n    {\"name\": \"intExpr5\", \"symbols\": [\"nonNegInt\"], \"postprocess\": d => parseInt(d[0])},\n    {\"name\": \"intExpr5\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"intExpr1\", \"_\", {\"literal\":\")\"}], \"postprocess\": d => d[2]},\n    {\"name\": \"posInt$ebnf$1\", \"symbols\": []},\n    {\"name\": \"posInt$ebnf$1\", \"symbols\": [\"posInt$ebnf$1\", /[0-9]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"posInt\", \"symbols\": [/[1-9]/, \"posInt$ebnf$1\"], \"postprocess\": d => d[0] + d[1].join(\"\")},\n    {\"name\": \"nonNegInt\", \"symbols\": [{\"literal\":\"0\"}], \"postprocess\": _ => \"0\"},\n    {\"name\": \"nonNegInt\", \"symbols\": [\"posInt\"], \"postprocess\": id},\n    {\"name\": \"int$ebnf$1\", \"symbols\": [{\"literal\":\"-\"}], \"postprocess\": id},\n    {\"name\": \"int$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"int\", \"symbols\": [\"int$ebnf$1\", \"nonNegInt\"], \"postprocess\": d => (d[0] || \"\") + d[1]},\n    {\"name\": \"decimal$ebnf$1\", \"symbols\": [{\"literal\":\"-\"}], \"postprocess\": id},\n    {\"name\": \"decimal$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"decimal$ebnf$2\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"decimal$ebnf$2\", \"symbols\": [\"decimal$ebnf$2\", /[0-9]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"decimal$ebnf$3$subexpression$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"decimal$ebnf$3$subexpression$1$ebnf$1\", \"symbols\": [\"decimal$ebnf$3$subexpression$1$ebnf$1\", /[0-9]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"decimal$ebnf$3$subexpression$1$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"decimal$ebnf$3$subexpression$1$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [\"decimal$ebnf$3$subexpression$1$ebnf$2$subexpression$1$ebnf$1\", /[0-9]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"decimal$ebnf$3$subexpression$1$ebnf$2$subexpression$1\", \"symbols\": [{\"literal\":\"(\"}, \"decimal$ebnf$3$subexpression$1$ebnf$2$subexpression$1$ebnf$1\", {\"literal\":\")\"}]},\n    {\"name\": \"decimal$ebnf$3$subexpression$1$ebnf$2\", \"symbols\": [\"decimal$ebnf$3$subexpression$1$ebnf$2$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"decimal$ebnf$3$subexpression$1$ebnf$2\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"decimal$ebnf$3$subexpression$1\", \"symbols\": [{\"literal\":\".\"}, \"decimal$ebnf$3$subexpression$1$ebnf$1\", \"decimal$ebnf$3$subexpression$1$ebnf$2\"]},\n    {\"name\": \"decimal$ebnf$3\", \"symbols\": [\"decimal$ebnf$3$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"decimal$ebnf$3\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"decimal\", \"symbols\": [\"decimal$ebnf$1\", \"decimal$ebnf$2\", \"decimal$ebnf$3\"], \"postprocess\":  d => (d[0] || \"\") + d[1].join(\"\")\n        + (d[2] ? \".\" + d[2][1].join(\"\")\n                      + (d[2][2] ? \"(\"+d[2][2][1].join(\"\")+\")\"\n                                 : \"\")\n                : \"\") },\n    {\"name\": \"hertz$string$1\", \"symbols\": [{\"literal\":\"h\"}, {\"literal\":\"z\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"hertz\", \"symbols\": [\"hertz$string$1\"]},\n    {\"name\": \"hertz$string$2\", \"symbols\": [{\"literal\":\"H\"}, {\"literal\":\"z\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"hertz\", \"symbols\": [\"hertz$string$2\"]}\n]\n  , ParserStart: \"top1\"\n}\nif (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {\n   module.exports = grammar;\n} else {\n   window.grammar = grammar;\n}\n})();\n",
    "/**\n * Functions for working with pythagorean and neutral pythagorean intervals\n * @copyright 2021 Matthew Yacavone (matthew [at] yacavone [dot] net)\n * @module pythagorean\n **/\n\nconst pf = require('primes-and-factors');\nconst ntw = require('number-to-words');\nconst Fraction = require('fraction.js');\nconst Interval = require('./interval.js');\n\nfunction mod(a,n) {\n  return ((a % n) + n) % n;\n}\n\n/**\n  * Constructs an interval from a pythagorean degree and offset\n  *\n  * @param {integer} d\n  * @param {Fraction} o\n  * @returns {Interval}\n  */\nfunction pyInterval(d,a,b) {\n  const ox4 = Fraction(a,b).mul(4 * Math.sign(d));\n  if (ox4.d != 1) {\n    throw \"offset does not have denominator 1, 2, or 4\"\n  }\n  const zd = d - Math.sign(d);\n  const ng = mod(zd * 4 + 3, 7) - 3;\n  const g = ng * 2 + ox4.s * ox4.n * 7;\n  return Interval({ 2: Fraction(g,4).sub((zd - g) / 7).neg(),\n                    3: Fraction(g,4) });\n}\n\n/**\n  * Checks whether the given interval is pythagorean\n  *\n  * @param {Interval} i\n  * @returns {boolean}\n  */\nfunction isPythagorean(a,b) {\n  const i = new Interval(a,b);\n  const e2 = (i['2'] || Fraction(0));\n  const e3 = (i['3'] || Fraction(0));\n  return Object.entries(i).length == (!!i['2'] + !!i['3'])\n         && e3.mul(4).d == 1 && e2.add(e3).d == 1;\n}\n\n/**\n  * For a given pythagorean interval `(3/2)^(g/4) * 2^v`, returns the `g`.\n  *\n  * @param {Interval} i\n  * @returns {integer}\n  */\nfunction pyGenerator(a,b) {\n  const i = new Interval(a,b);\n  const g = (i['3'] || Fraction(0)).mul(4);\n  if (g.d != 1) {\n    throw \"interval is not pythagorean\";\n  }\n  return g.s * g.n;\n}\n\n/**\n  * For a given pythagorean interval `(3/2)^(g/4) * 2^v`, returns the `v`.\n  *\n  * @param {Interval} i\n  * @returns {integer}\n  */\nfunction pyOctaves(a,b) {\n  const i = new Interval(a,b);\n  const e2 = (i['2'] || Fraction(0));\n  const e3 = (i['3'] || Fraction(0));\n  const v = e2.add(e3);\n  if (v.d != 1) {\n    throw \"interval is not pythagorean\";\n  }\n  return v.s * v.n;\n}\n\n/**\n  * Returns the degree of the given pythagorean interval\n  *\n  * @param {Interval} i\n  * @returns {integer}\n  */\nfunction pyDegree(a,b) {\n  const i = new Interval(a,b);\n  const g = pyGenerator(i);\n  const v = pyOctaves(i);\n  const zd = g + v * 7;\n  return zd == 0 ? 1 : zd + Math.sign(zd);\n}\n\n/**\n  * Returns the offset of the given pythagorean interval\n  *\n  * @param {Interval} i\n  * @returns {Fraction}\n  */\nfunction pyOffset(a,b) {\n  const i = new Interval(a,b);\n  const g = pyGenerator(i);\n  const v = pyOctaves(i);\n  const zd = g + v * 7;\n  const szd = zd == 0 ? 1 : Math.sign(zd)\n  return Fraction(szd * (2 * Math.floor((4 * g + 3) / 7) - g), 4);\n}\n\n/**\n  * Reduces a pythagorean degree so it lies between 1 and 7\n  *\n  * @param {integer} d\n  * @returns {integer}\n  */\nfunction pyRedDeg(d) {\n  return mod(d - Math.sign(d), 7) + 1;\n}\n\n/**\n  * Checks whether a given degree (of a pythagorean interval) is a unison,\n  * fourth, or fifth\n  *\n  * @param {integer} d\n  * @returns {boolean}\n  */\nfunction isPerfectDeg(d) {\n  return pyRedDeg(d) == 1 || pyRedDeg(d) == 4 || pyRedDeg(d) == 5;\n}\n\nfunction case2(n, a, b) {\n  if (n == 0 || !n) { return a; }\n  return b;\n}\n\nfunction case3(n, a, b, c) {\n  if (n == 0 || !n) { return a; }\n  if (n == 1) { return b; }\n  return c;\n}\n\n/**\n  * Returns the quality of the given pythagorean interval\n  *\n  * @param {Interval} i\n  * @param {{verbosity: integer}=} opts verbosity can be the default 0\n  *                                     (e.g. \"d\"), 1 (e.g. \"dim\"), or 2\n  *                                     (e.g. \"diminished\")\n  * @returns {string}\n  */\nfunction pyQuality(a,b, opts) {\n  // if only two arguments are given, the second one may be `opts`!\n  if (!opts && typeof b == 'object' && b != null) {\n      opts = b;\n      b = undefined;\n  }\n  const {verbosity} = opts || {};\n  let o = pyOffset(a,b);\n  if (isPerfectDeg(pyDegree(a,b))) {\n    if (o == 0    ) { return case2(verbosity, \"P\", \"perfect\"); }\n  }\n  else {\n    if (o == 0    ) { return case2(verbosity, \"n\", \"neutral\"); }\n    if (o == 0.25 ) { return case2(verbosity, \"sM\", \"semi-major\"); }\n    if (o == 0.5  ) { return case2(verbosity, \"M\", \"major\"); }\n    if (o == -0.25) { return case2(verbosity, \"sm\", \"semi-minor\"); }\n    if (o == -0.5 ) { return case2(verbosity, \"m\", \"minor\"); }\n    o = o.sub(o.s,2);\n  }\n  if (o == 0.5 ) { return case3(verbosity, \"sA\", \"semi-aug\", \"semi-augmented\"); }\n  if (o == 1   ) { return case3(verbosity, \"A\", \"aug\", \"augmented\"); }\n  if (o == -0.5) { return case3(verbosity, \"sd\", \"semi-dim\", \"semi-diminished\"); }\n  if (o == -1  ) { return case3(verbosity, \"d\", \"dim\", \"diminished\"); }\n  if (o ==  2 && verbosity == 2) { return \"doubly augmented\"; }\n  if (o == -2 && verbosity == 2) { return \"doubly diminished\"; }\n  if (o > 0 && o.d == 1) { return o.n + case3(verbosity, \"A\", \"-aug\", \"-augmented\"); }\n  if (o > 0 && o.d != 1) { return o.toFraction() + case3(verbosity, \"-A\", \"-aug\", \"-augmented\"); }\n  if (o < 0 && o.d == 1) { return o.n + case3(verbosity, \"d\", \"-dim\", \"-diminished\"); }\n  if (o < 0 && o.d != 1) { return o.neg().toFraction() + case3(verbosity, \"-d\", \"-dim\", \"-diminished\"); }\n}\n\nfunction pyDegreeString(d, verbosity) {\n  if (verbosity == 0 || !verbosity) {\n    return d;\n  }\n  if (verbosity == 1) {\n    return ntw.toOrdinal(Math.abs(d));\n  }\n  if (Math.abs(d) == 1) {\n    return \"unison\"\n  }\n  if (Math.abs(d) == 8) {\n    return \"octave\"\n  }\n  return ntw.toWordsOrdinal(Math.abs(d));\n}\n\n/**\n  * Returns the symbol of the given pythagorean interval\n  *\n  * @param {Interval} i\n  * @param {{verbosity: integer}=} opts verbosity can be the default 0\n  *                                     (e.g. \"d2\"), 1 (e.g. \"dim 2nd\"), or 2\n  *                                     (e.g. \"diminished second\")\n  * @returns {string}\n  */\nfunction pySymb(a,b, opts) {\n  // if only two arguments are given, the second one may be `opts`!\n  if (!opts && typeof b == 'object' && b != null) {\n      opts = b;\n      b = undefined;\n  }\n  const {verbosity} = opts || {};\n  const d = pyDegree(a,b);\n  const d_str = case2(verbosity, \"\", \" \") + pyDegreeString(d, verbosity);\n  const down_str = verbosity && d < 0 ? \" down\" : \"\";\n  return pyQuality(a,b, opts) + d_str + down_str;\n}\n\n/**\n  * Returns the interval to A of the given base note name (i.e. A, B, C, D, E,\n  * F or G) within a single octave of scientific pitch notation\n  *\n  * @param {string} baseNote\n  * @returns {Interval}\n  */\nfunction baseNoteIntvToA(x) {\n  if (x == \"C\") { return pyInterval(-6, 0.5) /* M6 down */ }\n  if (x == \"D\") { return pyInterval(-5, 0)   /* P5 down */ }\n  if (x == \"E\") { return pyInterval(-4, 0)   /* P4 down */ }\n  if (x == \"F\") { return pyInterval(-3, 0.5) /* M3 down */ }\n  if (x == \"G\") { return pyInterval(-2, 0.5) /* M2 down */ }\n  if (x == \"A\") { return Interval(1)         /* P1 */      }\n  if (x == \"B\") { return pyInterval(2, 0.5)  /* M2 */      }\n}\n\n/**\n  * Returns the octave in scientific pitch notation of the given interval to A4\n  *\n  * @param {Interval} intvToA4\n  * @returns {integer}\n  */\nfunction octaveOfIntvToA4(a,b) {\n  const intvToA4 = Interval(a,b);\n  const intvToC4 = intvToA4.div(baseNoteIntvToA(\"C\"));\n  return 4 + Math.floor(Math.log(intvToC4.valueOf()) / Math.log(2));\n}\n\n/**\n  * Returns the note name of the given non-neutral pythagorean interval to A4.\n  * The returned string uses ASCII instead of uniode wherever possible iff the\n  * second argument is given and is true\n  *\n  * @param {Interval} intvToA4\n  * @param {Boolean} [useASCII=false]\n  * @returns {string}\n  */\nfunction pyNote(intvToA4, useASCII) {\n  const intvToF4 = Interval(intvToA4).div(baseNoteIntvToA(\"F\"));\n  if (!isPythagorean(intvToF4) || (intvToF4['3'] && intvToF4['3'].d != 1)) {\n    throw \"interval is not a non-neutral pythagorean interval\"\n  }\n  const e3 = intvToF4['3'] ? intvToF4['3'].s * intvToF4['3'].n : Fraction(0);\n  const zd = mod(4*e3, 7);\n  let o = Math.floor(e3 / 7);\n\n  let octave = octaveOfIntvToA4(intvToA4);\n  if (octave == 4) { octave = \"\"; }\n\n  let baseNote;\n  if (zd == 0) { baseNote = \"F\"; }\n  if (zd == 1) { baseNote = \"G\"; }\n  if (zd == 2) { baseNote = \"A\"; }\n  if (zd == 3) { baseNote = \"B\"; }\n  if (zd == 4) { baseNote = \"C\"; }\n  if (zd == 5) { baseNote = \"D\"; }\n  if (zd == 6) { baseNote = \"E\"; }\n\n  let accidentals = \"\";\n  if (o == 0 && baseNote == \"A\" && octave != \"\") {\n    accidentals += \"\";\n  }\n  while (o > 1) {\n    accidentals += useASCII ? \"X\" : \"\";\n    o -= 2;\n  }\n  if (o == 1) {\n    accidentals += useASCII ? \"#\" : \"\";\n  }\n  while (o < -1) {\n    if (useASCII) {\n      accidentals += \"b\";\n      o += 1;\n    } else {\n      accidentals += \"\";\n      o += 2;\n    }\n  }\n  if (o == -1) {\n    accidentals += useASCII ? \"b\" : \"\";\n  }\n\n  return baseNote + accidentals + octave;\n}\n\nmodule['exports'].pyInterval = pyInterval;\nmodule['exports'].isPythagorean = isPythagorean;\nmodule['exports'].pyGenerator = pyGenerator;\nmodule['exports'].pyOctaves = pyOctaves;\nmodule['exports'].pyDegree = pyDegree;\nmodule['exports'].pyOffset = pyOffset;\nmodule['exports'].pyRedDeg = pyRedDeg;\nmodule['exports'].isPerfectDeg = isPerfectDeg;\nmodule['exports'].pyQuality = pyQuality;\nmodule['exports'].pySymb = pySymb;\nmodule['exports'].pySymb = pySymb;\nmodule['exports'].baseNoteIntvToA = baseNoteIntvToA;\nmodule['exports'].octaveOfIntvToA4 = octaveOfIntvToA4;\nmodule['exports'].pyNote = pyNote;\n",
    "/**\n * @license Fraction.js v4.0.12 09/09/2015\n * http://www.xarg.org/2014/03/rational-numbers-in-javascript/\n *\n * Copyright (c) 2015, Robert Eisele (robert@xarg.org)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n **/\n\n\n/**\n *\n * This class offers the possibility to calculate fractions.\n * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.\n *\n * Array/Object form\n * [ 0 => <nominator>, 1 => <denominator> ]\n * [ n => <nominator>, d => <denominator> ]\n *\n * Integer form\n * - Single integer value\n *\n * Double form\n * - Single double value\n *\n * String form\n * 123.456 - a simple double\n * 123/456 - a string fraction\n * 123.'456' - a double with repeating decimal places\n * 123.(456) - synonym\n * 123.45'6' - a double with repeating last place\n * 123.45(6) - synonym\n *\n * Example:\n *\n * var f = new Fraction(\"9.4'31'\");\n * f.mul([-4, 3]).div(4.9);\n *\n */\n\n(function(root) {\n\n  \"use strict\";\n\n  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.\n  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.\n  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits\n  var MAX_CYCLE_LEN = 2000;\n\n  // Parsed data to avoid calling \"new\" all the time\n  var P = {\n    \"s\": 1,\n    \"n\": 0,\n    \"d\": 1\n  };\n\n  function createError(name) {\n\n    function errorConstructor() {\n      var temp = Error.apply(this, arguments);\n      temp['name'] = this['name'] = name;\n      this['stack'] = temp['stack'];\n      this['message'] = temp['message'];\n    }\n\n    /**\n     * Error constructor\n     *\n     * @constructor\n     */\n    function IntermediateInheritor() { }\n    IntermediateInheritor.prototype = Error.prototype;\n    errorConstructor.prototype = new IntermediateInheritor();\n\n    return errorConstructor;\n  }\n\n  var DivisionByZero = Fraction['DivisionByZero'] = createError('DivisionByZero');\n  var InvalidParameter = Fraction['InvalidParameter'] = createError('InvalidParameter');\n\n  function assign(n, s) {\n\n    if (isNaN(n = parseInt(n, 10))) {\n      throwInvalidParam();\n    }\n    return n * s;\n  }\n\n  function throwInvalidParam() {\n    throw new InvalidParameter();\n  }\n\n  var parse = function(p1, p2) {\n\n    var n = 0, d = 1, s = 1;\n    var v = 0, w = 0, x = 0, y = 1, z = 1;\n\n    var A = 0, B = 1;\n    var C = 1, D = 1;\n\n    var N = 10000000;\n    var M;\n\n    if (p1 === undefined || p1 === null) {\n      /* void */\n    } else if (p2 !== undefined) {\n      n = p1;\n      d = p2;\n      s = n * d;\n    } else\n      switch (typeof p1) {\n\n        case \"object\":\n          {\n            if (\"d\" in p1 && \"n\" in p1) {\n              n = p1[\"n\"];\n              d = p1[\"d\"];\n              if (\"s\" in p1)\n                n *= p1[\"s\"];\n            } else if (0 in p1) {\n              n = p1[0];\n              if (1 in p1)\n                d = p1[1];\n            } else {\n              throwInvalidParam();\n            }\n            s = n * d;\n            break;\n          }\n        case \"number\":\n          {\n            if (p1 < 0) {\n              s = p1;\n              p1 = -p1;\n            }\n\n            if (p1 % 1 === 0) {\n              n = p1;\n            } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow\n\n              if (p1 >= 1) {\n                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));\n                p1 /= z;\n              }\n\n              // Using Farey Sequences\n              // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/\n\n              while (B <= N && D <= N) {\n                M = (A + C) / (B + D);\n\n                if (p1 === M) {\n                  if (B + D <= N) {\n                    n = A + C;\n                    d = B + D;\n                  } else if (D > B) {\n                    n = C;\n                    d = D;\n                  } else {\n                    n = A;\n                    d = B;\n                  }\n                  break;\n\n                } else {\n\n                  if (p1 > M) {\n                    A += C;\n                    B += D;\n                  } else {\n                    C += A;\n                    D += B;\n                  }\n\n                  if (B > N) {\n                    n = C;\n                    d = D;\n                  } else {\n                    n = A;\n                    d = B;\n                  }\n                }\n              }\n              n *= z;\n            } else if (isNaN(p1) || isNaN(p2)) {\n              d = n = NaN;\n            }\n            break;\n          }\n        case \"string\":\n          {\n            B = p1.match(/\\d+|./g);\n\n            if (B === null)\n              throwInvalidParam();\n\n            if (B[A] === '-') {// Check for minus sign at the beginning\n              s = -1;\n              A++;\n            } else if (B[A] === '+') {// Check for plus sign at the beginning\n              A++;\n            }\n\n            if (B.length === A + 1) { // Check if it's just a simple number \"1234\"\n              w = assign(B[A++], s);\n            } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number\n\n              if (B[A] !== '.') { // Handle 0.5 and .5\n                v = assign(B[A++], s);\n              }\n              A++;\n\n              // Check for decimal places\n              if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === \"'\" && B[A + 3] === \"'\") {\n                w = assign(B[A], s);\n                y = Math.pow(10, B[A].length);\n                A++;\n              }\n\n              // Check for repeating places\n              if (B[A] === '(' && B[A + 2] === ')' || B[A] === \"'\" && B[A + 2] === \"'\") {\n                x = assign(B[A + 1], s);\n                z = Math.pow(10, B[A + 1].length) - 1;\n                A += 3;\n              }\n\n            } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction \"123/456\" or \"123:456\"\n              w = assign(B[A], s);\n              y = assign(B[A + 2], 1);\n              A += 3;\n            } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction \"123 1/2\"\n              v = assign(B[A], s);\n              w = assign(B[A + 2], s);\n              y = assign(B[A + 4], 1);\n              A += 5;\n            }\n\n            if (B.length <= A) { // Check for more tokens on the stack\n              d = y * z;\n              s = /* void */\n              n = x + d * v + z * w;\n              break;\n            }\n\n            /* Fall through on error */\n          }\n        default:\n          throwInvalidParam();\n      }\n\n    if (d === 0) {\n      throw new DivisionByZero();\n    }\n\n    P[\"s\"] = s < 0 ? -1 : 1;\n    P[\"n\"] = Math.abs(n);\n    P[\"d\"] = Math.abs(d);\n  };\n\n  function modpow(b, e, m) {\n\n    var r = 1;\n    for (; e > 0; b = (b * b) % m, e >>= 1) {\n\n      if (e & 1) {\n        r = (r * b) % m;\n      }\n    }\n    return r;\n  }\n\n\n  function cycleLen(n, d) {\n\n    for (; d % 2 === 0;\n      d /= 2) {\n    }\n\n    for (; d % 5 === 0;\n      d /= 5) {\n    }\n\n    if (d === 1) // Catch non-cyclic numbers\n      return 0;\n\n    // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:\n    // 10^(d-1) % d == 1\n    // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,\n    // as we want to translate the numbers to strings.\n\n    var rem = 10 % d;\n    var t = 1;\n\n    for (; rem !== 1; t++) {\n      rem = rem * 10 % d;\n\n      if (t > MAX_CYCLE_LEN)\n        return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`\n    }\n    return t;\n  }\n\n\n  function cycleStart(n, d, len) {\n\n    var rem1 = 1;\n    var rem2 = modpow(10, len, d);\n\n    for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)\n      // Solve 10^s == 10^(s+t) (mod d)\n\n      if (rem1 === rem2)\n        return t;\n\n      rem1 = rem1 * 10 % d;\n      rem2 = rem2 * 10 % d;\n    }\n    return 0;\n  }\n\n  function gcd(a, b) {\n\n    if (!a)\n      return b;\n    if (!b)\n      return a;\n\n    while (1) {\n      a %= b;\n      if (!a)\n        return b;\n      b %= a;\n      if (!b)\n        return a;\n    }\n  };\n\n  /**\n   * Module constructor\n   *\n   * @constructor\n   * @param {number|Fraction=} a\n   * @param {number=} b\n   */\n  function Fraction(a, b) {\n\n    if (!(this instanceof Fraction)) {\n      return new Fraction(a, b);\n    }\n\n    parse(a, b);\n\n    if (Fraction['REDUCE']) {\n      a = gcd(P[\"d\"], P[\"n\"]); // Abuse a\n    } else {\n      a = 1;\n    }\n\n    this[\"s\"] = P[\"s\"];\n    this[\"n\"] = P[\"n\"] / a;\n    this[\"d\"] = P[\"d\"] / a;\n  }\n\n  /**\n   * Boolean global variable to be able to disable automatic reduction of the fraction\n   *\n   */\n  Fraction['REDUCE'] = 1;\n\n  Fraction.prototype = {\n\n    \"s\": 1,\n    \"n\": 0,\n    \"d\": 1,\n\n    /**\n     * Calculates the absolute value\n     *\n     * Ex: new Fraction(-4).abs() => 4\n     **/\n    \"abs\": function() {\n\n      return new Fraction(this[\"n\"], this[\"d\"]);\n    },\n\n    /**\n     * Inverts the sign of the current fraction\n     *\n     * Ex: new Fraction(-4).neg() => 4\n     **/\n    \"neg\": function() {\n\n      return new Fraction(-this[\"s\"] * this[\"n\"], this[\"d\"]);\n    },\n\n    /**\n     * Adds two rational numbers\n     *\n     * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => 467 / 30\n     **/\n    \"add\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n        this[\"s\"] * this[\"n\"] * P[\"d\"] + P[\"s\"] * this[\"d\"] * P[\"n\"],\n        this[\"d\"] * P[\"d\"]\n      );\n    },\n\n    /**\n     * Subtracts two rational numbers\n     *\n     * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => -427 / 30\n     **/\n    \"sub\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n        this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * this[\"d\"] * P[\"n\"],\n        this[\"d\"] * P[\"d\"]\n      );\n    },\n\n    /**\n     * Multiplies two rational numbers\n     *\n     * Ex: new Fraction(\"-17.(345)\").mul(3) => 5776 / 111\n     **/\n    \"mul\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n        this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"n\"],\n        this[\"d\"] * P[\"d\"]\n      );\n    },\n\n    /**\n     * Divides two rational numbers\n     *\n     * Ex: new Fraction(\"-17.(345)\").inverse().div(3)\n     **/\n    \"div\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n        this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"d\"],\n        this[\"d\"] * P[\"n\"]\n      );\n    },\n\n    /**\n     * Clones the actual object\n     *\n     * Ex: new Fraction(\"-17.(345)\").clone()\n     **/\n    \"clone\": function() {\n      return new Fraction(this);\n    },\n\n    /**\n     * Calculates the modulo of two rational numbers - a more precise fmod\n     *\n     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)\n     **/\n    \"mod\": function(a, b) {\n\n      if (isNaN(this['n']) || isNaN(this['d'])) {\n        return new Fraction(NaN);\n      }\n\n      if (a === undefined) {\n        return new Fraction(this[\"s\"] * this[\"n\"] % this[\"d\"], 1);\n      }\n\n      parse(a, b);\n      if (0 === P[\"n\"] && 0 === this[\"d\"]) {\n        Fraction(0, 0); // Throw DivisionByZero\n      }\n\n      /*\n       * First silly attempt, kinda slow\n       *\n       return that[\"sub\"]({\n       \"n\": num[\"n\"] * Math.floor((this.n / this.d) / (num.n / num.d)),\n       \"d\": num[\"d\"],\n       \"s\": this[\"s\"]\n       });*/\n\n      /*\n       * New attempt: a1 / b1 = a2 / b2 * q + r\n       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r\n       * => (b2 * a1 % a2 * b1) / (b1 * b2)\n       */\n      return new Fraction(\n        this[\"s\"] * (P[\"d\"] * this[\"n\"]) % (P[\"n\"] * this[\"d\"]),\n        P[\"d\"] * this[\"d\"]\n      );\n    },\n\n    /**\n     * Calculates the fractional gcd of two rational numbers\n     *\n     * Ex: new Fraction(5,8).gcd(3,7) => 1/56\n     */\n    \"gcd\": function(a, b) {\n\n      parse(a, b);\n\n      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)\n\n      return new Fraction(gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]), P[\"d\"] * this[\"d\"]);\n    },\n\n    /**\n     * Calculates the fractional lcm of two rational numbers\n     *\n     * Ex: new Fraction(5,8).lcm(3,7) => 15\n     */\n    \"lcm\": function(a, b) {\n\n      parse(a, b);\n\n      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)\n\n      if (P[\"n\"] === 0 && this[\"n\"] === 0) {\n        return new Fraction;\n      }\n      return new Fraction(P[\"n\"] * this[\"n\"], gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]));\n    },\n\n    /**\n     * Calculates the ceil of a rational number\n     *\n     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)\n     **/\n    \"ceil\": function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      if (isNaN(this[\"n\"]) || isNaN(this[\"d\"])) {\n        return new Fraction(NaN);\n      }\n      return new Fraction(Math.ceil(places * this[\"s\"] * this[\"n\"] / this[\"d\"]), places);\n    },\n\n    /**\n     * Calculates the floor of a rational number\n     *\n     * Ex: new Fraction('4.(3)').floor() => (4 / 1)\n     **/\n    \"floor\": function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      if (isNaN(this[\"n\"]) || isNaN(this[\"d\"])) {\n        return new Fraction(NaN);\n      }\n      return new Fraction(Math.floor(places * this[\"s\"] * this[\"n\"] / this[\"d\"]), places);\n    },\n\n    /**\n     * Rounds a rational numbers\n     *\n     * Ex: new Fraction('4.(3)').round() => (4 / 1)\n     **/\n    \"round\": function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      if (isNaN(this[\"n\"]) || isNaN(this[\"d\"])) {\n        return new Fraction(NaN);\n      }\n      return new Fraction(Math.round(places * this[\"s\"] * this[\"n\"] / this[\"d\"]), places);\n    },\n\n    /**\n     * Gets the inverse of the fraction, means numerator and denominator are exchanged\n     *\n     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3\n     **/\n    \"inverse\": function() {\n\n      return new Fraction(this[\"s\"] * this[\"d\"], this[\"n\"]);\n    },\n\n    /**\n     * Calculates the fraction to some integer exponent\n     *\n     * Ex: new Fraction(-1,2).pow(-3) => -8\n     */\n    \"pow\": function(m) {\n\n      if (m < 0) {\n        return new Fraction(Math.pow(this['s'] * this[\"d\"], -m), Math.pow(this[\"n\"], -m));\n      } else {\n        return new Fraction(Math.pow(this['s'] * this[\"n\"], m), Math.pow(this[\"d\"], m));\n      }\n    },\n\n    /**\n     * Check if two rational numbers are the same\n     *\n     * Ex: new Fraction(19.6).equals([98, 5]);\n     **/\n    \"equals\": function(a, b) {\n\n      parse(a, b);\n      return this[\"s\"] * this[\"n\"] * P[\"d\"] === P[\"s\"] * P[\"n\"] * this[\"d\"]; // Same as compare() === 0\n    },\n\n    /**\n     * Check if two rational numbers are the same\n     *\n     * Ex: new Fraction(19.6).equals([98, 5]);\n     **/\n    \"compare\": function(a, b) {\n\n      parse(a, b);\n      var t = (this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * P[\"n\"] * this[\"d\"]);\n      return (0 < t) - (t < 0);\n    },\n\n    \"simplify\": function(eps) {\n\n      // First naive implementation, needs improvement\n\n      if (isNaN(this['n']) || isNaN(this['d'])) {\n        return this;\n      }\n\n      var cont = this['abs']()['toContinued']();\n\n      eps = eps || 0.001;\n\n      function rec(a) {\n        if (a.length === 1)\n          return new Fraction(a[0]);\n        return rec(a.slice(1))['inverse']()['add'](a[0]);\n      }\n\n      for (var i = 0; i < cont.length; i++) {\n        var tmp = rec(cont.slice(0, i + 1));\n        if (tmp['sub'](this['abs']())['abs']().valueOf() < eps) {\n          return tmp['mul'](this['s']);\n        }\n      }\n      return this;\n    },\n\n    /**\n     * Check if two rational numbers are divisible\n     *\n     * Ex: new Fraction(19.6).divisible(1.5);\n     */\n    \"divisible\": function(a, b) {\n\n      parse(a, b);\n      return !(!(P[\"n\"] * this[\"d\"]) || ((this[\"n\"] * P[\"d\"]) % (P[\"n\"] * this[\"d\"])));\n    },\n\n    /**\n     * Returns a decimal representation of the fraction\n     *\n     * Ex: new Fraction(\"100.'91823'\").valueOf() => 100.91823918239183\n     **/\n    'valueOf': function() {\n\n      return this[\"s\"] * this[\"n\"] / this[\"d\"];\n    },\n\n    /**\n     * Returns a string-fraction representation of a Fraction object\n     *\n     * Ex: new Fraction(\"1.'3'\").toFraction() => \"4 1/3\"\n     **/\n    'toFraction': function(excludeWhole) {\n\n      var whole, str = \"\";\n      var n = this[\"n\"];\n      var d = this[\"d\"];\n      if (this[\"s\"] < 0) {\n        str += '-';\n      }\n\n      if (d === 1) {\n        str += n;\n      } else {\n\n        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {\n          str += whole;\n          str += \" \";\n          n %= d;\n        }\n\n        str += n;\n        str += '/';\n        str += d;\n      }\n      return str;\n    },\n\n    /**\n     * Returns a latex representation of a Fraction object\n     *\n     * Ex: new Fraction(\"1.'3'\").toLatex() => \"\\frac{4}{3}\"\n     **/\n    'toLatex': function(excludeWhole) {\n\n      var whole, str = \"\";\n      var n = this[\"n\"];\n      var d = this[\"d\"];\n      if (this[\"s\"] < 0) {\n        str += '-';\n      }\n\n      if (d === 1) {\n        str += n;\n      } else {\n\n        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {\n          str += whole;\n          n %= d;\n        }\n\n        str += \"\\\\frac{\";\n        str += n;\n        str += '}{';\n        str += d;\n        str += '}';\n      }\n      return str;\n    },\n\n    /**\n     * Returns an array of continued fraction elements\n     *\n     * Ex: new Fraction(\"7/8\").toContinued() => [0,1,7]\n     */\n    'toContinued': function() {\n\n      var t;\n      var a = this['n'];\n      var b = this['d'];\n      var res = [];\n\n      if (isNaN(a) || isNaN(b)) {\n        return res;\n      }\n\n      do {\n        res.push(Math.floor(a / b));\n        t = a % b;\n        a = b;\n        b = t;\n      } while (a !== 1);\n\n      return res;\n    },\n\n    /**\n     * Creates a string representation of a fraction with all digits\n     *\n     * Ex: new Fraction(\"100.'91823'\").toString() => \"100.(91823)\"\n     **/\n    'toString': function(dec) {\n\n      var g;\n      var N = this[\"n\"];\n      var D = this[\"d\"];\n\n      if (isNaN(N) || isNaN(D)) {\n        return \"NaN\";\n      }\n\n      if (!Fraction['REDUCE']) {\n        g = gcd(N, D);\n        N /= g;\n        D /= g;\n      }\n\n      dec = dec || 15; // 15 = decimal places when no repitation\n\n      var cycLen = cycleLen(N, D); // Cycle length\n      var cycOff = cycleStart(N, D, cycLen); // Cycle start\n\n      var str = this['s'] === -1 ? \"-\" : \"\";\n\n      str += N / D | 0;\n\n      N %= D;\n      N *= 10;\n\n      if (N)\n        str += \".\";\n\n      if (cycLen) {\n\n        for (var i = cycOff; i--;) {\n          str += N / D | 0;\n          N %= D;\n          N *= 10;\n        }\n        str += \"(\";\n        for (var i = cycLen; i--;) {\n          str += N / D | 0;\n          N %= D;\n          N *= 10;\n        }\n        str += \")\";\n      } else {\n        for (var i = dec; N && i--;) {\n          str += N / D | 0;\n          N %= D;\n          N *= 10;\n        }\n      }\n      return str;\n    }\n  };\n\n  if (typeof define === \"function\" && define[\"amd\"]) {\n    define([], function() {\n      return Fraction;\n    });\n  } else if (typeof exports === \"object\") {\n    Object.defineProperty(Fraction, \"__esModule\", { 'value': true });\n    Fraction['default'] = Fraction;\n    Fraction['Fraction'] = Fraction;\n    module['exports'] = Fraction;\n  } else {\n    root['Fraction'] = Fraction;\n  }\n\n})(this);\n",
    "var MathUtils = module.exports = {\n\tisOdd: function(num){\n\t\treturn num & 1 === 1;\n\t},\n\tisEven: function(num){\n\t\treturn num & 1 === 0;\n\t},\n\n\tpowermod: function powermod(num, exp, mod){\n\t\tif(exp === 1) return num % mod;\n\t\tif(MathUtils.isOdd(exp)){\n\t\t\treturn (num * powermod(num, exp-1, mod)) % mod;\n\t\t}\n\t\treturn Math.pow(powermod(num, exp/2, mod), 2) % mod;\n\t},\n\n\tisPrime: function(num){\n\t\treturn MathUtils.fastIsPrime(num) && MathUtils.slowIsPrime(num);\n\t},\n\tslowIsPrime: function(num){\n\t\tif(MathUtils.isEven(num)) return false;\n\t\tfor(var i = 3, max = Math.sqrt(num); i < max; i += 2){\n\t\t\tif(num % i === 0) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tfastIsPrime: function(num){\n\t\treturn MathUtils.powermod(3, num-1, num) === 1;\n\t},\n\n\trandomPrime: function(len){\n\t\tvar num = Math.floor(Math.pow(10, len || 3) * Math.random());\n\t\tif(MathUtils.isEven(num)) num++;\n\t\twhile(!MathUtils.isPrime(num)) num += 2;\n\t\treturn num;\n\t},\n\n\tgcd: function gcd(a, b){\n\t\tif(b === 0) return a;\n\t\treturn gcd(b, a % b);\n\t},\n\tegcd: function eea(a, b){\n\t\tif(b === 0) return [a, 1, 0];\n\t\tvar tmp = eea(b, a % b);\n\t\tvar ss = tmp[1],\n\t\t\tts = tmp[2];\n\t\treturn [tmp[0], ts, ss - Math.floor(a/b) * ts];\n\t},\n\n\tmodularInverse: function(a, b){\n\t\tvar arr = MathUtils.egcd(a, b);\n\t\t//if(arr[1] * a + arr[2] * b !== arr[0]) throw Error(\"Wrong EGCD: \" + sum);\n\t\treturn arr[1];\n\t}\n};",
    "(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(getSymbolShortDisplay).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(' ')\n                                 + \"  \"\n                                 + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(' ')     );\n        return this.name + \"  \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n            // Having right set here will prevent the right state and its children\n            // form being garbage collected\n            state.right = undefined;\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var lines = buffer\n                .split(\"\\n\")\n                .slice(\n                    Math.max(0, this.line - 5), \n                    this.line\n                );\n\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var col = this.index - this.lastLineBreak;\n            var lastLineDigits = String(this.line).length;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += lines\n                .map(function(line, i) {\n                    return pad(this.line - lines.length + i + 1, lastLineDigits) + \" \" + line;\n                }, this)\n                .join(\"\\n\");\n            message += \"\\n\" + pad(\"\", lastLineDigits + col) + \"^\\n\";\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n\n        function pad(n, length) {\n            var s = String(n);\n            return Array(length - s.length + 1).join(\" \") + s;\n        }\n    }\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (true) {\n            try {\n                token = lexer.next();\n                if (!token) {\n                    break;\n                }\n            } catch (e) {\n                // Create the next column so that the error reporter\n                // can display the correctly predicted states.\n                var nextColumn = new Column(this.grammar, this.current + 1);\n                this.table.push(nextColumn);\n                var err = new Error(this.reportLexerError(e));\n                err.offset = this.current;\n                err.token = e.token;\n                throw err;\n            }\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.reportLexerError = function(lexerError) {\n        var tokenDisplay, lexerMessage;\n        // Planning to add a token property to moo's thrown error\n        // even on erroring tokens to be used in error display below\n        var token = lexerError.token;\n        if (token) {\n            tokenDisplay = \"input \" + JSON.stringify(token.text[0]) + \" (lexer error)\";\n            lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        } else {\n            tokenDisplay = \"input (lexer error)\";\n            lexerMessage = lexerError.message;\n        }\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var tokenDisplay = (token.type ? token.type + \" token: \" : \"\") + JSON.stringify(token.value !== undefined ? token.value : token);\n        var lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {\n        var lines = [];\n        lines.push(lexerMessage);\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== \"string\";\n            });\n\n        if (expectantStates.length === 0) {\n            lines.push('Unexpected ' + tokenDisplay + '. I did not expect any more input. Here is the state of my parse table:\\n');\n            this.displayStateStack(lastColumn.states, lines);\n        } else {\n            lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\\n');\n            // Display a \"state stack\" for each expectant state\n            // - which shows you how this state came to be, step by step.\n            // If there is more than one derivation, we only display the first one.\n            var stateStacks = expectantStates\n                .map(function(state) {\n                    return this.buildFirstStateStack(state, []) || [state];\n                }, this);\n            // Display each state that is expecting a terminal symbol next.\n            stateStacks.forEach(function(stateStack) {\n                var state = stateStack[0];\n                var nextSymbol = state.rule.symbols[state.dot];\n                var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n                lines.push('A ' + symbolDisplay + ' based on:');\n                this.displayStateStack(stateStack, lines);\n            }, this);\n        }\n        lines.push(\"\");\n        return lines.join(\"\\n\");\n    }\n    \n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push('    ^ ' + sameDisplayCount + ' more lines identical to this');\n                }\n                sameDisplayCount = 0;\n                lines.push('    ' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        return getSymbolLongDisplay(symbol);\n    };\n\n    /*\n    Builds a the first state stack. You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a\n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n\n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an single state stack.\n\n    */\n    Parser.prototype.buildFirstStateStack = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return null\n            // to eliminate this path from the results, because\n            // we don't know how to display it meaningfully\n            return null;\n        }\n        if (state.wantedBy.length === 0) {\n            return [state];\n        }\n        var prevState = state.wantedBy[0];\n        var childVisited = [state].concat(visited);\n        var childResult = this.buildFirstStateStack(prevState, childVisited);\n        if (childResult === null) {\n            return null;\n        }\n        return [state].concat(childResult);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    function getSymbolLongDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return 'character matching ' + symbol;\n            } else if (symbol.type) {\n                return symbol.type + ' token';\n            } else if (symbol.test) {\n                return 'token matching ' + String(symbol.test);\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    function getSymbolShortDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return symbol.toString();\n            } else if (symbol.type) {\n                return '%' + symbol.type;\n            } else if (symbol.test) {\n                return '<' + String(symbol.test) + '>';\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n",
    "/*!\n * Number-To-Words util\n * @version v1.2.4\n * @link https://github.com/marlun78/number-to-words\n * @author Martin Eneqvist (https://github.com/marlun78)\n * @contributors Aleksey Pilyugin (https://github.com/pilyugin),Jeremiah Hall (https://github.com/jeremiahrhall),Adriano Melo (https://github.com/adrianomelo),dmrzn (https://github.com/dmrzn)\n * @license MIT\n */\n!function(){\"use strict\";var e=\"object\"==typeof self&&self.self===self&&self||\"object\"==typeof global&&global.global===global&&global||this,t=9007199254740991;function f(e){return!(\"number\"!=typeof e||e!=e||e===1/0||e===-1/0)}function l(e){return\"number\"==typeof e&&Math.abs(e)<=t}var n=/(hundred|thousand|(m|b|tr|quadr)illion)$/,r=/teen$/,o=/y$/,i=/(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve)$/,s={zero:\"zeroth\",one:\"first\",two:\"second\",three:\"third\",four:\"fourth\",five:\"fifth\",six:\"sixth\",seven:\"seventh\",eight:\"eighth\",nine:\"ninth\",ten:\"tenth\",eleven:\"eleventh\",twelve:\"twelfth\"};function h(e){return n.test(e)||r.test(e)?e+\"th\":o.test(e)?e.replace(o,\"ieth\"):i.test(e)?e.replace(i,a):e}function a(e,t){return s[t]}var u=10,d=100,p=1e3,v=1e6,b=1e9,y=1e12,c=1e15,g=9007199254740992,m=[\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\",\"ten\",\"eleven\",\"twelve\",\"thirteen\",\"fourteen\",\"fifteen\",\"sixteen\",\"seventeen\",\"eighteen\",\"nineteen\"],w=[\"zero\",\"ten\",\"twenty\",\"thirty\",\"forty\",\"fifty\",\"sixty\",\"seventy\",\"eighty\",\"ninety\"];function x(e,t){var n,r=parseInt(e,10);if(!f(r))throw new TypeError(\"Not a finite number: \"+e+\" (\"+typeof e+\")\");if(!l(r))throw new RangeError(\"Input is not a safe number, its either too large or too small.\");return n=function e(t){var n,r,o=arguments[1];if(0===t)return o?o.join(\" \").replace(/,$/,\"\"):\"zero\";o||(o=[]);t<0&&(o.push(\"minus\"),t=Math.abs(t));t<20?(n=0,r=m[t]):t<d?(n=t%u,r=w[Math.floor(t/u)],n&&(r+=\"-\"+m[n],n=0)):t<p?(n=t%d,r=e(Math.floor(t/d))+\" hundred\"):t<v?(n=t%p,r=e(Math.floor(t/p))+\" thousand,\"):t<b?(n=t%v,r=e(Math.floor(t/v))+\" million,\"):t<y?(n=t%b,r=e(Math.floor(t/b))+\" billion,\"):t<c?(n=t%y,r=e(Math.floor(t/y))+\" trillion,\"):t<=g&&(n=t%c,r=e(Math.floor(t/c))+\" quadrillion,\");o.push(r);return e(n,o)}(r),t?h(n):n}var M={toOrdinal:function(e){var t=parseInt(e,10);if(!f(t))throw new TypeError(\"Not a finite number: \"+e+\" (\"+typeof e+\")\");if(!l(t))throw new RangeError(\"Input is not a safe number, its either too large or too small.\");var n=String(t),r=Math.abs(t%100),o=11<=r&&r<=13,i=n.charAt(n.length-1);return n+(o?\"th\":\"1\"===i?\"st\":\"2\"===i?\"nd\":\"3\"===i?\"rd\":\"th\")},toWords:x,toWordsOrdinal:function(e){return h(x(e))}};\"undefined\"!=typeof exports?(\"undefined\"!=typeof module&&module.exports&&(exports=module.exports=M),exports.numberToWords=M):e.numberToWords=M}();",
    "\"use strict\";\n\nvar primeFactor = {\n\n  isPrime: function isPrime(num) {\n    // Non integer or any number less than 2 is not prime\n    if (!Number.isInteger(num) || num < 2) return false;\n    // Even number: only prime if it is 2\n    if (num % 2 === 0) return num === 2;\n    // Odd number divisible by 3: only prime if it is 3\n    if (num % 3 === 0) return num === 3;\n    // Search for factor 5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37...\n    // up to and including square root of input number\n    var floorSqrt = Math.floor(Math.sqrt(num));\n    for (var i = 5; i <= floorSqrt; i += 6) {\n      if (num % i === 0 || num % (i + 2) === 0) return false;\n    }\n    return true;\n  },\n\n  calculate: function calculate(inputNum) {\n    var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var repeat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (!Number.isInteger(inputNum)) return result;\n    var num = Math.abs(inputNum);\n    if (num < 2) return result;\n    var theSqrt = Math.sqrt(num);\n    var x = 2;\n    if (num % x) {\n      x = 3;\n      if (num % x) {\n        x = 5;\n        var add = 2;\n        while (num % x && x < theSqrt) {\n          // search numbers: 5, 7, 11, 13, 17, 19, 23...\n          x += add;\n          // add each time: 2, 4, 2, 4, 2, 4, 2...\n          add = 6 - add;\n        }\n      }\n    }\n\n    x = x <= theSqrt ? x : num;\n\n    if (!repeat) {\n      var index = result.indexOf(x);\n      if (index < 0) result.push(x);\n    } else result.push(x);\n\n    return x === num ? result : this.calculate(num / x, result, repeat);\n  },\n\n  getFactors: function getFactors(num) {\n    return this.calculate(num, [], true);\n  },\n\n  getUniqueFactors: function getUniqueFactors(num) {\n    return this.calculate(num, [], false);\n  },\n\n  getPrimeExponentObject: function getPrimeExponentObject(num) {\n    var factors = this.calculate(num);\n    var countObject = {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = factors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var factor = _step.value;\n\n        if (Number.isFinite(countObject[factor])) {\n          countObject[factor] += 1;\n        } else {\n          countObject[factor] = 1;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return countObject;\n  },\n\n  getFrequency: function getFrequency(num) {\n    var countObject = this.getPrimeExponentObject(num);\n    var result = [];\n\n    for (var key in countObject) {\n      if ({}.hasOwnProperty.call(countObject, key)) {\n        var obj = {\n          factor: Number(key),\n          times: countObject[key]\n        };\n        result.push(obj);\n      }\n    }\n    return result;\n  }\n\n};\n\nmodule.exports = primeFactor;"
  ]
}